<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gen87.X3 Real Architecture Demo</title>
  <!-- Golden Layout (REQUIRED - Architecture compliance) -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css">
  <style>
    :root {
      --bg-dark: #0a0a0f;
      --bg-panel: #12121a;
      --border: #2a2a3a;
      --accent: #00ff88;
      --warning: #ffaa00;
      --error: #ff4444;
      --nats: #27aae1;
      --text: #e0e0e0;
      --text-dim: #808090;
    }
    
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    html, body {
      font-family: 'JetBrains Mono', 'Fira Code', monospace;
      background: var(--bg-dark);
      color: var(--text);
      height: 100%;
      overflow: hidden;
    }
    
    /* Golden Layout container */
    #layout-container {
      width: 100%;
      height: 100%;
    }
    
    /* Golden Layout overrides */
    .lm_header { background: var(--bg-panel) !important; }
    .lm_tab { background: var(--bg-dark) !important; }
    .lm_tab.lm_active { background: var(--bg-panel) !important; border-bottom: 2px solid var(--accent) !important; }
    .lm_content { background: var(--bg-panel) !important; }
    .lm_splitter { background: var(--border) !important; }
    
    /* Panel content styles */
    .panel-content {
      padding: 1rem;
      height: 100%;
      overflow: auto;
    }
    
    .panel-content h2 {
      font-size: 0.9rem;
      color: var(--accent);
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
    }
    
    /* Video Panel */
    .video-panel video {
      width: 100%;
      max-width: 400px;
      border-radius: 8px;
      background: #000;
    }
    
    /* Canvas Panel */
    .canvas-panel {
      position: relative;
      background: var(--bg-dark);
      height: 100%;
      cursor: none;
    }
    
    #gesture-cursor {
      position: absolute;
      width: 24px;
      height: 24px;
      border: 2px solid var(--accent);
      border-radius: 50%;
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: all 0.05s ease-out;
      z-index: 1000;
    }
    
    #gesture-cursor.pressing {
      background: rgba(0, 255, 136, 0.3);
      transform: translate(-50%, -50%) scale(1.5);
    }
    
    #gesture-cursor.pinching {
      background: rgba(255, 170, 0, 0.3);
      border-color: var(--warning);
    }
    
    /* Status badges */
    .status-bar {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }
    
    .badge {
      padding: 0.25rem 0.75rem;
      border-radius: 4px;
      font-size: 0.7rem;
      font-weight: 600;
    }
    
    .badge.connected { background: var(--accent); color: var(--bg-dark); }
    .badge.disconnected { background: var(--error); color: white; }
    .badge.nats { background: var(--nats); color: white; }
    .badge.fallback { background: var(--warning); color: var(--bg-dark); }
    
    /* Controls */
    .controls {
      display: flex;
      gap: 0.5rem;
      margin: 1rem 0;
    }
    
    button {
      padding: 0.5rem 1rem;
      border: 1px solid var(--accent);
      background: transparent;
      color: var(--accent);
      border-radius: 4px;
      cursor: pointer;
      font-family: inherit;
      font-size: 0.75rem;
      transition: all 0.2s;
    }
    
    button:hover { background: var(--accent); color: var(--bg-dark); }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    /* Debug sections */
    .debug-section {
      margin-bottom: 1.5rem;
    }
    
    .debug-section h3 {
      font-size: 0.7rem;
      color: var(--text-dim);
      margin-bottom: 0.5rem;
      text-transform: uppercase;
    }
    
    .metric {
      display: flex;
      justify-content: space-between;
      padding: 0.2rem 0;
      border-bottom: 1px solid var(--border);
      font-size: 0.75rem;
    }
    
    .metric-label { color: var(--text-dim); }
    .metric-value { font-weight: 600; }
    .metric-value.real { color: var(--accent); }
    .metric-value.nats { color: var(--nats); }
    
    /* Pipeline visualization */
    .pipeline-stage {
      padding: 0.5rem;
      margin-bottom: 0.25rem;
      border-radius: 4px;
      border-left: 3px solid var(--border);
      font-size: 0.7rem;
    }
    
    .pipeline-stage.active { border-left-color: var(--accent); background: rgba(0, 255, 136, 0.05); }
    .pipeline-stage.nats { border-left-color: var(--nats); background: rgba(39, 170, 225, 0.05); }
    
    /* Event log */
    #event-log {
      font-size: 0.65rem;
      max-height: 150px;
      overflow-y: auto;
      background: var(--bg-dark);
      padding: 0.5rem;
      border-radius: 4px;
    }
    
    .log-entry { padding: 0.15rem 0; border-bottom: 1px solid var(--border); }
    .log-entry.pointer { color: var(--accent); }
    .log-entry.nats { color: var(--nats); }
    .log-entry.fsm { color: #88aaff; }
    .log-entry.error { color: var(--error); }
  </style>
</head>
<body>
  <div id="layout-container"></div>
  
  <script type="module">
    // ============================================================
    // GEN87.X3 REAL ARCHITECTURE DEMO
    // ============================================================
    // ‚úÖ Golden Layout - Dockable panels
    // ‚úÖ NATS WebSocket - Event bus (with fallback)
    // ‚úÖ Hexagonal Adapters - Port pattern
    // ‚úÖ Zod Validation - All stages
    // ============================================================
    
    // === CDN IMPORTS ===
    // NOTE: Using latest versions verified on esm.sh
    import { GoldenLayout } from 'https://esm.sh/golden-layout@2.6.0';
    import { connect, StringCodec } from 'https://esm.sh/nats.ws@1.30.3';
    import { 
      GestureRecognizer,
      FilesetResolver,
    } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8';
    import { z } from 'https://esm.sh/zod@3.24.1';
    import { createActor, createMachine, assign } from 'https://esm.sh/xstate@5.19.2';
    
    // ============================================================
    // ZOD SCHEMAS (Contract Validation)
    // ============================================================
    
    const NormalizedLandmarkSchema = z.object({
      x: z.number().min(0).max(1),
      y: z.number().min(0).max(1),
      z: z.number(),
      visibility: z.number().optional(),
    });
    
    const SensorFrameSchema = z.object({
      timestamp: z.number(),
      landmarks: z.array(z.array(NormalizedLandmarkSchema)),
      gestures: z.array(z.object({
        categoryName: z.string(),
        score: z.number(),
      })).optional(),
    });
    
    const SmoothedFrameSchema = z.object({
      timestamp: z.number(),
      rawLandmarks: z.array(z.array(NormalizedLandmarkSchema)),
      smoothedLandmarks: z.array(z.array(NormalizedLandmarkSchema)),
      gestures: z.array(z.object({
        categoryName: z.string(),
        score: z.number(),
      })).optional(),
    });
    
    const FSMActionSchema = z.object({
      state: z.enum(['idle', 'tracking', 'pressing', 'dragging', 'pinching', 'released']),
      gesture: z.string().nullable(),
      x: z.number(),
      y: z.number(),
      pressure: z.number(),
      timestamp: z.number(),
    });
    
    const PointerEventOutSchema = z.object({
      eventType: z.enum(['pointerdown', 'pointermove', 'pointerup', 'pointercancel']),
      pointerId: z.number(),
      pointerType: z.enum(['mouse', 'pen', 'touch']),
      clientX: z.number(),
      clientY: z.number(),
      pressure: z.number(),
      button: z.number(),
      buttons: z.number(),
      isPrimary: z.boolean(),
    });
    
    // ============================================================
    // NATS SUBSTRATE ADAPTER (Event Bus)
    // ============================================================
    
    const NATS_SUBJECTS = {
      SENSOR: 'hfo.sensor.frame',
      SMOOTHED: 'hfo.smoother.frame',
      FSM: 'hfo.fsm.action',
      POINTER: 'hfo.pointer.event',
    };
    
    class NatsSubstrateAdapter {
      constructor() {
        this.nc = null;
        this.sc = StringCodec();
        this.connected = false;
        this.subscriptions = new Map();
      }
      
      async connect(servers = 'ws://localhost:4222') {
        try {
          this.nc = await connect({ servers });
          this.connected = true;
          console.log('[NATS] Connected to', servers);
          return true;
        } catch (err) {
          console.warn('[NATS] Connection failed:', err.message);
          this.connected = false;
          return false;
        }
      }
      
      async publish(subject, data) {
        if (!this.connected) return false;
        try {
          const payload = this.sc.encode(JSON.stringify(data));
          this.nc.publish(subject, payload);
          return true;
        } catch (err) {
          console.error('[NATS] Publish error:', err);
          return false;
        }
      }
      
      subscribe(subject, callback) {
        if (!this.connected) return null;
        try {
          const sub = this.nc.subscribe(subject);
          (async () => {
            for await (const msg of sub) {
              const data = JSON.parse(this.sc.decode(msg.data));
              callback(data);
            }
          })();
          this.subscriptions.set(subject, sub);
          return sub;
        } catch (err) {
          console.error('[NATS] Subscribe error:', err);
          return null;
        }
      }
      
      async close() {
        if (this.nc) {
          await this.nc.drain();
          this.connected = false;
        }
      }
    }
    
    // ============================================================
    // ONE EURO ADAPTER (Smoothing)
    // ============================================================
    
    class LowPassFilter {
      constructor(alpha) { this.alpha = alpha; this.y = null; this.s = null; }
      filter(value, alpha = this.alpha) {
        if (this.y === null) { this.y = value; this.s = value; }
        else { this.alpha = alpha; this.y = alpha * value + (1 - alpha) * this.s; this.s = this.y; }
        return this.y;
      }
      reset() { this.y = null; this.s = null; }
    }
    
    class OneEuroAdapter {
      constructor(config = {}) {
        this.minCutoff = config.minCutoff ?? 1.0;
        this.beta = config.beta ?? 0.007;
        this.dCutoff = config.dCutoff ?? 1.0;
        this.filters = new Map();
        this.lastTimestamp = null;
      }
      
      _alpha(cutoff, dt) {
        const tau = 1.0 / (2 * Math.PI * cutoff);
        return 1.0 / (1.0 + tau / dt);
      }
      
      _getFilter(key) {
        if (!this.filters.has(key)) {
          this.filters.set(key, {
            x: new LowPassFilter(this._alpha(this.minCutoff, 1/60)),
            dx: new LowPassFilter(this._alpha(this.dCutoff, 1/60)),
          });
        }
        return this.filters.get(key);
      }
      
      smooth(sensorFrame) {
        const dt = this.lastTimestamp ? (sensorFrame.timestamp - this.lastTimestamp) / 1000 : 1/60;
        this.lastTimestamp = sensorFrame.timestamp;
        
        const smoothedLandmarks = sensorFrame.landmarks.map((hand, handIdx) =>
          hand.map((lm, lmIdx) => {
            const key = `${handIdx}-${lmIdx}`;
            const filter = this._getFilter(key);
            const prevX = filter.x.y ?? lm.x;
            const prevY = filter.dx.y ?? lm.y;
            const dx = (lm.x - prevX) / dt;
            const dy = (lm.y - prevY) / dt;
            const speed = Math.sqrt(dx * dx + dy * dy);
            const cutoff = this.minCutoff + this.beta * speed;
            const alpha = this._alpha(cutoff, dt);
            return { x: filter.x.filter(lm.x, alpha), y: filter.dx.filter(lm.y, alpha), z: lm.z, visibility: lm.visibility };
          })
        );
        
        return { timestamp: sensorFrame.timestamp, rawLandmarks: sensorFrame.landmarks, smoothedLandmarks, gestures: sensorFrame.gestures };
      }
      
      reset() { this.filters.clear(); this.lastTimestamp = null; }
    }
    
    // ============================================================
    // XSTATE FSM ADAPTER
    // ============================================================
    
    const gestureFSM = createMachine({
      id: 'gesture',
      initial: 'idle',
      context: { x: 0.5, y: 0.5, pressure: 0, gesture: null, timestamp: 0 },
      states: {
        idle: {
          on: { HAND_DETECTED: { target: 'tracking', actions: assign({ x: ({ event }) => event.x, y: ({ event }) => event.y, timestamp: ({ event }) => event.timestamp }) } }
        },
        tracking: {
          on: {
            HAND_LOST: 'idle',
            MOVE: { actions: assign({ x: ({ event }) => event.x, y: ({ event }) => event.y, timestamp: ({ event }) => event.timestamp }) },
            CLOSED_FIST: { target: 'pressing', actions: assign({ gesture: 'Closed_Fist', pressure: 0.8 }) },
            PINCH: { target: 'pinching', actions: assign({ gesture: 'Pinch', pressure: 0.5 }) },
          }
        },
        pressing: {
          on: { HAND_LOST: 'idle', MOVE: { target: 'dragging', actions: assign({ x: ({ event }) => event.x, y: ({ event }) => event.y }) }, OPEN: { target: 'released' } }
        },
        dragging: {
          on: { HAND_LOST: 'idle', MOVE: { actions: assign({ x: ({ event }) => event.x, y: ({ event }) => event.y }) }, OPEN: 'released' }
        },
        pinching: {
          on: { HAND_LOST: 'idle', MOVE: { actions: assign({ x: ({ event }) => event.x, y: ({ event }) => event.y }) }, OPEN: 'released' }
        },
        released: {
          always: 'tracking',
          entry: assign({ gesture: null, pressure: 0 })
        }
      }
    });
    
    class XStateFSMAdapter {
      constructor() { this.actor = createActor(gestureFSM); this.actor.start(); }
      
      process(smoothedFrame) {
        const state = this.actor.getSnapshot();
        if (smoothedFrame.smoothedLandmarks.length === 0) {
          this.actor.send({ type: 'HAND_LOST' });
        } else {
          const indexTip = smoothedFrame.smoothedLandmarks[0][8];
          const gesture = smoothedFrame.gestures?.[0]?.categoryName;
          if (state.value === 'idle') {
            this.actor.send({ type: 'HAND_DETECTED', x: indexTip.x, y: indexTip.y, timestamp: smoothedFrame.timestamp });
          } else {
            this.actor.send({ type: 'MOVE', x: indexTip.x, y: indexTip.y, timestamp: smoothedFrame.timestamp });
            if (gesture === 'Closed_Fist') this.actor.send({ type: 'CLOSED_FIST' });
            else if (gesture === 'Victory' || gesture === 'Thumb_Up') this.actor.send({ type: 'PINCH' });
            else if (gesture === 'Open_Palm' || gesture === 'Pointing_Up') this.actor.send({ type: 'OPEN' });
          }
        }
        const newState = this.actor.getSnapshot();
        return { state: newState.value, gesture: newState.context.gesture, x: newState.context.x, y: newState.context.y, pressure: newState.context.pressure, timestamp: smoothedFrame.timestamp };
      }
    }
    
    // ============================================================
    // POINTER EVENT ADAPTER
    // ============================================================
    
    class PointerEventAdapter {
      constructor(config = {}) { this.pointerId = config.pointerId ?? 1; this.pointerType = config.pointerType ?? 'touch'; this.lastState = 'idle'; }
      
      emit(fsmAction, target) {
        const clientX = (1 - fsmAction.x) * target.bounds.width + target.bounds.x;
        const clientY = fsmAction.y * target.bounds.height + target.bounds.y;
        let eventType = 'pointermove', button = -1, buttons = 0;
        if (fsmAction.state === 'pressing' && this.lastState === 'tracking') { eventType = 'pointerdown'; button = 0; buttons = 1; }
        else if (fsmAction.state === 'released') { eventType = 'pointerup'; button = 0; buttons = 0; }
        else if (fsmAction.state === 'dragging' || fsmAction.state === 'pressing') { buttons = 1; }
        else if (fsmAction.state === 'idle') { this.lastState = fsmAction.state; return null; }
        this.lastState = fsmAction.state;
        return { eventType, pointerId: this.pointerId, pointerType: this.pointerType, clientX, clientY, pressure: fsmAction.pressure, button, buttons, isPrimary: true };
      }
    }
    
    class DOMAdapter {
      constructor(targetElement) { this.target = targetElement; }
      inject(pointerEvent) {
        const event = new PointerEvent(pointerEvent.eventType, { ...pointerEvent, bubbles: true, cancelable: true });
        this.target.dispatchEvent(event);
        return true;
      }
    }
    
    // ============================================================
    // MEDIAPIPE ADAPTER
    // ============================================================
    
    class MediaPipeAdapter {
      constructor() { this.recognizer = null; }
      
      async initialize(videoElement) {
        const vision = await FilesetResolver.forVisionTasks('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm');
        this.recognizer = await GestureRecognizer.createFromOptions(vision, {
          baseOptions: { modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task', delegate: 'GPU' },
          runningMode: 'VIDEO', numHands: 1
        });
      }
      
      async sense(video, timestamp) {
        if (!this.recognizer) return { timestamp, landmarks: [], gestures: [] };
        const results = this.recognizer.recognizeForVideo(video, timestamp);
        return { timestamp, landmarks: results.landmarks || [], gestures: results.gestures?.[0] || [] };
      }
    }
    
    // ============================================================
    // GOLDEN LAYOUT SETUP
    // ============================================================
    
    const layoutConfig = {
      root: {
        type: 'row',
        content: [
          { type: 'component', componentType: 'video-panel', title: 'üìπ Camera', width: 25 },
          { type: 'component', componentType: 'canvas-panel', title: 'üéØ Target', width: 50 },
          { type: 'component', componentType: 'debug-panel', title: 'üî¨ Debug', width: 25 }
        ]
      }
    };
    
    // ============================================================
    // APPLICATION STATE
    // ============================================================
    
    let goldenLayout = null;
    let nats = null;
    let useNats = false;
    let isRunning = false;
    let animationId = null;
    let frameCount = 0;
    let lastFpsTime = performance.now();
    
    // Adapters
    let sensorAdapter = null;
    let smootherAdapter = null;
    let fsmAdapter = null;
    let emitterAdapter = null;
    let targetAdapter = null;
    
    // DOM refs (set by component factories)
    let videoEl = null;
    let canvasEl = null;
    let cursorEl = null;
    let logEl = null;
    let metricsEls = {};
    let statusEls = {};
    
    // ============================================================
    // LOGGING
    // ============================================================
    
    function log(message, type = 'info') {
      if (!logEl) return;
      const entry = document.createElement('div');
      entry.className = `log-entry ${type}`;
      entry.textContent = `[${new Date().toISOString().slice(11,19)}] ${message}`;
      logEl.insertBefore(entry, logEl.firstChild);
      if (logEl.children.length > 50) logEl.removeChild(logEl.lastChild);
    }
    
    // ============================================================
    // COMPONENT FACTORIES (Golden Layout)
    // ============================================================
    
    function createVideoPanel(container) {
      container.element.innerHTML = `
        <div class="panel-content video-panel">
          <h2>Stage 1: Sensor</h2>
          <video id="camera" autoplay playsinline muted></video>
          <div class="controls">
            <button id="btn-start">‚ñ∂ Start</button>
            <button id="btn-stop" disabled>‚èπ Stop</button>
          </div>
          <div class="status-bar" style="margin-top: 1rem;">
            <span class="badge" id="status-nats">NATS: --</span>
            <span class="badge" id="status-pipeline">Pipeline: --</span>
          </div>
          <div class="debug-section">
            <h3>Adapters</h3>
            <div class="metric"><span class="metric-label">MediaPipe</span><span class="metric-value real" id="status-sensor">READY</span></div>
            <div class="metric"><span class="metric-label">OneEuro</span><span class="metric-value real" id="status-smoother">READY</span></div>
            <div class="metric"><span class="metric-label">XState</span><span class="metric-value real" id="status-fsm">READY</span></div>
            <div class="metric"><span class="metric-label">Pointer</span><span class="metric-value real" id="status-emitter">READY</span></div>
          </div>
        </div>
      `;
      
      videoEl = container.element.querySelector('#camera');
      statusEls.nats = container.element.querySelector('#status-nats');
      statusEls.pipeline = container.element.querySelector('#status-pipeline');
      statusEls.sensor = container.element.querySelector('#status-sensor');
      statusEls.smoother = container.element.querySelector('#status-smoother');
      statusEls.fsm = container.element.querySelector('#status-fsm');
      statusEls.emitter = container.element.querySelector('#status-emitter');
      
      container.element.querySelector('#btn-start').addEventListener('click', startPipeline);
      container.element.querySelector('#btn-stop').addEventListener('click', stopPipeline);
    }
    
    function createCanvasPanel(container) {
      container.element.innerHTML = `
        <div class="panel-content canvas-panel" id="canvas-area">
          <div id="gesture-cursor"></div>
        </div>
      `;
      canvasEl = container.element.querySelector('#canvas-area');
      cursorEl = container.element.querySelector('#gesture-cursor');
      
      // Listen for REAL W3C PointerEvents
      canvasEl.addEventListener('pointerdown', (e) => {
        if (e.pointerType === 'touch' && e.pointerId === 1) log('üéØ pointerdown received', 'pointer');
      });
      canvasEl.addEventListener('pointerup', (e) => {
        if (e.pointerType === 'touch' && e.pointerId === 1) log('üéØ pointerup received', 'pointer');
      });
    }
    
    function createDebugPanel(container) {
      container.element.innerHTML = `
        <div class="panel-content">
          <h2>Pipeline Debug</h2>
          <div class="debug-section">
            <h3>Flow</h3>
            <div class="pipeline-stage active" id="stage-sensor">1. SENSE ‚Üí MediaPipe</div>
            <div class="pipeline-stage" id="stage-nats-1">‚Üì NATS: hfo.sensor.frame</div>
            <div class="pipeline-stage active" id="stage-smoother">2. SMOOTH ‚Üí OneEuro</div>
            <div class="pipeline-stage" id="stage-nats-2">‚Üì NATS: hfo.smoother.frame</div>
            <div class="pipeline-stage active" id="stage-fsm">3. FSM ‚Üí XState</div>
            <div class="pipeline-stage" id="stage-nats-3">‚Üì NATS: hfo.fsm.action</div>
            <div class="pipeline-stage active" id="stage-emitter">4. EMIT ‚Üí Pointer</div>
            <div class="pipeline-stage" id="stage-nats-4">‚Üì NATS: hfo.pointer.event</div>
            <div class="pipeline-stage active" id="stage-target">5. INJECT ‚Üí DOM</div>
          </div>
          <div class="debug-section">
            <h3>Metrics</h3>
            <div class="metric"><span class="metric-label">FPS</span><span class="metric-value" id="metric-fps">0</span></div>
            <div class="metric"><span class="metric-label">Raw X</span><span class="metric-value" id="metric-raw-x">-</span></div>
            <div class="metric"><span class="metric-label">Raw Y</span><span class="metric-value" id="metric-raw-y">-</span></div>
            <div class="metric"><span class="metric-label">Smooth X</span><span class="metric-value real" id="metric-smooth-x">-</span></div>
            <div class="metric"><span class="metric-label">Smooth Y</span><span class="metric-value real" id="metric-smooth-y">-</span></div>
            <div class="metric"><span class="metric-label">FSM</span><span class="metric-value real" id="metric-fsm">idle</span></div>
            <div class="metric"><span class="metric-label">NATS msgs</span><span class="metric-value nats" id="metric-nats">0</span></div>
          </div>
          <div class="debug-section">
            <h3>Log</h3>
            <div id="event-log"></div>
          </div>
        </div>
      `;
      
      logEl = container.element.querySelector('#event-log');
      metricsEls.fps = container.element.querySelector('#metric-fps');
      metricsEls.rawX = container.element.querySelector('#metric-raw-x');
      metricsEls.rawY = container.element.querySelector('#metric-raw-y');
      metricsEls.smoothX = container.element.querySelector('#metric-smooth-x');
      metricsEls.smoothY = container.element.querySelector('#metric-smooth-y');
      metricsEls.fsm = container.element.querySelector('#metric-fsm');
      metricsEls.nats = container.element.querySelector('#metric-nats');
      
      // NATS stage indicators
      statusEls.nats1 = container.element.querySelector('#stage-nats-1');
      statusEls.nats2 = container.element.querySelector('#stage-nats-2');
      statusEls.nats3 = container.element.querySelector('#stage-nats-3');
      statusEls.nats4 = container.element.querySelector('#stage-nats-4');
    }
    
    // ============================================================
    // NATS CONNECTION
    // ============================================================
    
    let natsMessageCount = 0;
    
    async function connectNats() {
      nats = new NatsSubstrateAdapter();
      const connected = await nats.connect('ws://localhost:4222');
      
      if (connected) {
        useNats = true;
        statusEls.nats.textContent = 'NATS: Connected';
        statusEls.nats.className = 'badge nats';
        statusEls.nats1.classList.add('nats');
        statusEls.nats2.classList.add('nats');
        statusEls.nats3.classList.add('nats');
        statusEls.nats4.classList.add('nats');
        log('‚úÖ NATS connected - using event bus', 'nats');
        
        // Subscribe to pipeline subjects for metrics
        nats.subscribe(NATS_SUBJECTS.POINTER, (data) => {
          natsMessageCount++;
          metricsEls.nats.textContent = natsMessageCount;
        });
      } else {
        useNats = false;
        statusEls.nats.textContent = 'NATS: Fallback';
        statusEls.nats.className = 'badge fallback';
        log('‚ö†Ô∏è NATS unavailable - using direct pipeline', 'error');
      }
    }
    
    // ============================================================
    // PIPELINE
    // ============================================================
    
    async function initializeAdapters() {
      log('Initializing adapters...', 'info');
      
      // Sensor
      statusEls.sensor.textContent = 'LOADING...';
      sensorAdapter = new MediaPipeAdapter();
      await sensorAdapter.initialize(videoEl);
      statusEls.sensor.textContent = 'ACTIVE';
      log('‚úÖ MediaPipeAdapter', 'pointer');
      
      // Smoother
      smootherAdapter = new OneEuroAdapter({ minCutoff: 1.0, beta: 0.007 });
      statusEls.smoother.textContent = 'ACTIVE';
      log('‚úÖ OneEuroAdapter', 'pointer');
      
      // FSM
      fsmAdapter = new XStateFSMAdapter();
      statusEls.fsm.textContent = 'ACTIVE';
      log('‚úÖ XStateFSMAdapter', 'fsm');
      
      // Emitter
      emitterAdapter = new PointerEventAdapter({ pointerId: 1, pointerType: 'touch' });
      statusEls.emitter.textContent = 'ACTIVE';
      log('‚úÖ PointerEventAdapter', 'pointer');
      
      // Target
      targetAdapter = new DOMAdapter(canvasEl);
      log('‚úÖ DOMAdapter', 'pointer');
      
      return true;
    }
    
    async function pipelineLoop(timestamp) {
      if (!isRunning) return;
      
      try {
        // === STAGE 1: SENSE ===
        const sensorFrame = await sensorAdapter.sense(videoEl, timestamp);
        SensorFrameSchema.parse(sensorFrame); // Validate
        
        if (sensorFrame.landmarks.length > 0) {
          const tip = sensorFrame.landmarks[0][8];
          if (tip) {
            metricsEls.rawX.textContent = tip.x.toFixed(3);
            metricsEls.rawY.textContent = tip.y.toFixed(3);
          }
        }
        
        // Publish to NATS if connected
        if (useNats) await nats.publish(NATS_SUBJECTS.SENSOR, sensorFrame);
        
        // === STAGE 2: SMOOTH ===
        const smoothedFrame = smootherAdapter.smooth(sensorFrame);
        SmoothedFrameSchema.parse(smoothedFrame);
        
        if (smoothedFrame.smoothedLandmarks.length > 0) {
          const tip = smoothedFrame.smoothedLandmarks[0][8];
          if (tip) {
            metricsEls.smoothX.textContent = tip.x.toFixed(3);
            metricsEls.smoothY.textContent = tip.y.toFixed(3);
            
            // Update cursor
            const rect = canvasEl.getBoundingClientRect();
            cursorEl.style.left = `${(1 - tip.x) * rect.width}px`;
            cursorEl.style.top = `${tip.y * rect.height}px`;
          }
        }
        
        if (useNats) await nats.publish(NATS_SUBJECTS.SMOOTHED, smoothedFrame);
        
        // === STAGE 3: FSM ===
        const fsmAction = fsmAdapter.process(smoothedFrame);
        FSMActionSchema.parse(fsmAction);
        metricsEls.fsm.textContent = fsmAction.state;
        
        cursorEl.className = '';
        if (fsmAction.state === 'pressing' || fsmAction.state === 'dragging') cursorEl.classList.add('pressing');
        else if (fsmAction.state === 'pinching') cursorEl.classList.add('pinching');
        
        if (useNats) await nats.publish(NATS_SUBJECTS.FSM, fsmAction);
        
        // === STAGE 4: EMIT ===
        const rect = canvasEl.getBoundingClientRect();
        const pointerEvent = emitterAdapter.emit(fsmAction, { targetId: 'canvas', bounds: { x: rect.x, y: rect.y, width: rect.width, height: rect.height } });
        
        if (pointerEvent) {
          PointerEventOutSchema.parse(pointerEvent);
          if (useNats) await nats.publish(NATS_SUBJECTS.POINTER, pointerEvent);
          
          // === STAGE 5: INJECT ===
          targetAdapter.inject(pointerEvent);
        }
        
        // FPS
        frameCount++;
        const now = performance.now();
        if (now - lastFpsTime >= 1000) {
          metricsEls.fps.textContent = frameCount;
          frameCount = 0;
          lastFpsTime = now;
        }
        
      } catch (err) {
        log(`Error: ${err.message}`, 'error');
      }
      
      animationId = requestAnimationFrame(pipelineLoop);
    }
    
    async function startPipeline() {
      log('Starting...', 'info');
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
        videoEl.srcObject = stream;
        await videoEl.play();
        
        await connectNats();
        await initializeAdapters();
        
        isRunning = true;
        statusEls.pipeline.textContent = 'Pipeline: Running';
        statusEls.pipeline.className = 'badge connected';
        
        document.querySelector('#btn-start').disabled = true;
        document.querySelector('#btn-stop').disabled = false;
        
        log('üöÄ Pipeline started', 'pointer');
        animationId = requestAnimationFrame(pipelineLoop);
        
      } catch (err) {
        log(`Start failed: ${err.message}`, 'error');
      }
    }
    
    function stopPipeline() {
      isRunning = false;
      if (animationId) cancelAnimationFrame(animationId);
      if (videoEl.srcObject) { videoEl.srcObject.getTracks().forEach(t => t.stop()); videoEl.srcObject = null; }
      if (nats) nats.close();
      
      statusEls.pipeline.textContent = 'Pipeline: Stopped';
      statusEls.pipeline.className = 'badge disconnected';
      
      document.querySelector('#btn-start').disabled = false;
      document.querySelector('#btn-stop').disabled = true;
      
      log('Pipeline stopped', 'info');
    }
    
    // ============================================================
    // INIT
    // ============================================================
    
    function init() {
      goldenLayout = new GoldenLayout(document.getElementById('layout-container'));
      
      goldenLayout.registerComponentFactoryFunction('video-panel', createVideoPanel);
      goldenLayout.registerComponentFactoryFunction('canvas-panel', createCanvasPanel);
      goldenLayout.registerComponentFactoryFunction('debug-panel', createDebugPanel);
      
      goldenLayout.loadLayout(layoutConfig);
      
      // Handle resize
      window.addEventListener('resize', () => goldenLayout.setSize(window.innerWidth, window.innerHeight));
      
      console.log('[Gen87.X3] Real Architecture Demo initialized');
      console.log('[Gen87.X3] To use NATS, start server: docker run -p 4222:4222 nats:latest');
    }
    
    init();
  </script>
</body>
</html>
