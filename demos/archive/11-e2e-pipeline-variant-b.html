<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>E2E Pipeline ‚Äî Variant B</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    
    :root {
      --bg: #0d1117;
      --surface: #161b22;
      --border: #30363d;
      --text: #c9d1d9;
      --text-dim: #8b949e;
      --accent: #58a6ff;
      --green: #3fb950;
      --orange: #f0883e;
      --red: #f85149;
      --purple: #a371f7;
      --yellow: #d29922;
    }
    
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* Header */
    header {
      padding: 16px 24px;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    header h1 {
      font-size: 1.4rem;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .badge {
      font-size: 0.65rem;
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 600;
    }
    
    .badge.gen { background: var(--accent); color: var(--bg); }
    .badge.real { background: var(--green); color: var(--bg); }
    .badge.fsm { background: var(--purple); color: white; }
    
    .input-mode-select {
      display: flex;
      gap: 8px;
    }
    
    .input-btn {
      padding: 8px 16px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-dim);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s;
    }
    
    .input-btn.active {
      border-color: var(--green);
      color: var(--green);
      background: rgba(63, 185, 80, 0.1);
    }
    
    .input-btn:hover:not(.active) { border-color: var(--accent); }
    
    /* Pipeline Visualization */
    .pipeline-strip {
      background: var(--surface);
      padding: 12px 24px;
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 0.85rem;
    }
    
    .pipeline-stage {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 12px;
      background: var(--bg);
      border-radius: 6px;
      border: 1px solid var(--border);
    }
    
    .pipeline-stage.active {
      border-color: var(--green);
      box-shadow: 0 0 8px rgba(63, 185, 80, 0.3);
    }
    
    .pipeline-stage .icon { font-size: 1rem; }
    .pipeline-stage .label { font-weight: 500; }
    .pipeline-stage .value {
      font-family: monospace;
      font-size: 0.75rem;
      color: var(--accent);
    }
    
    .pipeline-arrow {
      color: var(--text-dim);
      font-size: 1.2rem;
    }
    
    /* Main Layout */
    main {
      flex: 1;
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 0;
      overflow: hidden;
    }
    
    /* Target Area */
    .target-container {
      position: relative;
      background: #010409;
      overflow: hidden;
    }
    
    #targetArea {
      width: 100%;
      height: 100%;
      position: relative;
      cursor: none;
    }
    
    /* Crosshair */
    .crosshair {
      position: absolute;
      width: 40px;
      height: 40px;
      pointer-events: none;
      transform: translate(-50%, -50%);
      transition: opacity 0.2s;
    }
    
    .crosshair-ring {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 2px solid var(--green);
      border-radius: 50%;
      transition: all 0.15s;
    }
    
    .crosshair-dot {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 6px;
      height: 6px;
      background: var(--green);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.15s;
    }
    
    .crosshair.down .crosshair-ring {
      border-color: var(--accent);
      transform: scale(0.8);
    }
    
    .crosshair.down .crosshair-dot {
      background: var(--accent);
      transform: translate(-50%, -50%) scale(1.5);
    }
    
    /* Event Badges */
    .event-badges {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    .event-badge {
      padding: 6px 12px;
      border-radius: 20px;
      font-family: monospace;
      font-size: 0.8rem;
      font-weight: 600;
      animation: badgePop 0.3s ease-out;
      opacity: 0;
      transition: opacity 0.3s;
    }
    
    .event-badge.show { opacity: 1; }
    
    .event-badge.pointermove { background: rgba(63, 185, 80, 0.3); color: var(--green); }
    .event-badge.pointerdown { background: rgba(88, 166, 255, 0.3); color: var(--accent); }
    .event-badge.pointerup { background: rgba(163, 113, 247, 0.3); color: var(--purple); }
    .event-badge.pointercancel { background: rgba(248, 81, 73, 0.3); color: var(--red); }
    
    @keyframes badgePop {
      0% { transform: scale(0.8); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    /* Overlays */
    .overlay {
      position: absolute;
      padding: 12px;
      background: rgba(0, 0, 0, 0.85);
      border-radius: 8px;
      font-size: 0.75rem;
      border: 1px solid var(--border);
    }
    
    .overlay.status { top: 12px; left: 12px; }
    .overlay.metrics { top: 12px; right: 12px; }
    
    .status-row {
      display: flex;
      justify-content: space-between;
      gap: 20px;
      margin: 4px 0;
    }
    
    .status-value {
      font-family: monospace;
      font-weight: 600;
    }
    
    .status-value.green { color: var(--green); }
    .status-value.orange { color: var(--orange); }
    .status-value.red { color: var(--red); }
    .status-value.accent { color: var(--accent); }
    
    /* FSM State Indicator */
    .fsm-indicator {
      position: absolute;
      bottom: 20px;
      right: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 20px;
      background: rgba(0, 0, 0, 0.9);
      border-radius: 8px;
      border: 2px solid var(--border);
    }
    
    .fsm-dot {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      transition: all 0.3s;
    }
    
    .fsm-dot.DISARMED { background: var(--red); box-shadow: 0 0 12px var(--red); }
    .fsm-dot.ARMING { background: var(--yellow); box-shadow: 0 0 12px var(--yellow); }
    .fsm-dot.ARMED { background: var(--green); box-shadow: 0 0 12px var(--green); }
    .fsm-dot.DOWN_COMMIT { background: var(--accent); box-shadow: 0 0 12px var(--accent); }
    
    .fsm-state-text {
      font-family: monospace;
      font-size: 1rem;
      font-weight: 700;
    }
    
    .fsm-message {
      font-size: 0.75rem;
      color: var(--text-dim);
    }
    
    /* Sidebar */
    .sidebar {
      background: var(--surface);
      border-left: 1px solid var(--border);
      padding: 16px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    
    .panel {
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      padding: 14px;
    }
    
    .panel h3 {
      font-size: 0.85rem;
      color: var(--text-dim);
      margin-bottom: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .panel h3 .tag {
      font-size: 0.6rem;
      padding: 2px 6px;
      background: var(--purple);
      color: white;
      border-radius: 4px;
    }
    
    /* Smoother Tabs */
    .smoother-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
    }
    
    .smoother-tab {
      flex: 1;
      padding: 10px 6px;
      border: 1px solid var(--border);
      background: transparent;
      color: var(--text-dim);
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.75rem;
      font-weight: 500;
      transition: all 0.2s;
    }
    
    .smoother-tab.active {
      border-color: var(--green);
      color: var(--green);
      background: rgba(63, 185, 80, 0.1);
    }
    
    .smoother-tab:hover:not(.active) { border-color: var(--accent); }
    
    .smoother-panel { display: none; }
    .smoother-panel.active { display: block; }
    
    .control-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 8px 0;
    }
    
    .control-row label {
      font-size: 0.8rem;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .control-row .source {
      font-size: 0.55rem;
      color: var(--orange);
      padding: 1px 4px;
      background: rgba(210, 153, 34, 0.2);
      border-radius: 3px;
    }
    
    .control-row input[type="range"] {
      width: 90px;
      accent-color: var(--accent);
    }
    
    .control-row .val {
      font-family: monospace;
      font-size: 0.75rem;
      color: var(--accent);
      min-width: 40px;
      text-align: right;
    }
    
    /* Event Log */
    .event-log {
      max-height: 200px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.75rem;
    }
    
    .log-entry {
      padding: 6px 8px;
      margin-bottom: 3px;
      background: var(--bg);
      border-radius: 4px;
      border-left: 3px solid var(--border);
      display: flex;
      justify-content: space-between;
    }
    
    .log-entry.pointermove { border-left-color: var(--green); }
    .log-entry.pointerdown { border-left-color: var(--accent); }
    .log-entry.pointerup { border-left-color: var(--purple); }
    .log-entry.pointercancel { border-left-color: var(--red); }
    
    .log-type { font-weight: 600; }
    .log-coords { color: var(--text-dim); }
    
    /* Loading Overlay */
    #loadingOverlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      gap: 16px;
      z-index: 1000;
    }
    
    .spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border);
      border-top-color: var(--green);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin { to { transform: rotate(360deg); } }
    
    /* Footer */
    footer {
      padding: 10px 24px;
      background: var(--surface);
      border-top: 1px solid var(--border);
      font-size: 0.75rem;
      color: var(--text-dim);
      display: flex;
      justify-content: space-between;
    }
    
    footer a { color: var(--accent); text-decoration: none; }
  </style>
</head>
<body>
  <div id="loadingOverlay">
    <div class="spinner"></div>
    <div>Loading HFO Pipeline (REAL WASM)...</div>
  </div>
  
  <header>
    <h1>
      üîó E2E Pipeline ‚Äî Variant B
      <span class="badge gen">Gen87.X3</span>
      <span class="badge real">REAL</span>
      <span class="badge fsm">FSM</span>
    </h1>
    <div class="input-mode-select">
      <button class="input-btn active" data-input="mouse">üñ±Ô∏è Mouse</button>
      <button class="input-btn" data-input="camera">üì∑ Camera</button>
    </div>
  </header>
  
  <!-- Pipeline Visualization Strip -->
  <div class="pipeline-strip">
    <div class="pipeline-stage active" id="stage-input">
      <span class="icon">üì•</span>
      <span class="label">Input</span>
      <span class="value" id="inputType">Mouse</span>
    </div>
    <span class="pipeline-arrow">‚Üí</span>
    <div class="pipeline-stage" id="stage-smoother">
      <span class="icon">„Ä∞Ô∏è</span>
      <span class="label">Smoother</span>
      <span class="value" id="smootherType">1‚Ç¨</span>
    </div>
    <span class="pipeline-arrow">‚Üí</span>
    <div class="pipeline-stage" id="stage-fsm">
      <span class="icon">üîÑ</span>
      <span class="label">FSM</span>
      <span class="value" id="fsmStateStrip">DISARMED</span>
    </div>
    <span class="pipeline-arrow">‚Üí</span>
    <div class="pipeline-stage" id="stage-output">
      <span class="icon">üéØ</span>
      <span class="label">W3C Events</span>
      <span class="value" id="lastEventType">--</span>
    </div>
  </div>
  
  <main>
    <!-- Target Area -->
    <div class="target-container">
      <div id="targetArea">
        <!-- Crosshair -->
        <div class="crosshair" id="crosshair">
          <div class="crosshair-ring"></div>
          <div class="crosshair-dot"></div>
        </div>
        
        <!-- Event Badges -->
        <div class="event-badges">
          <div class="event-badge pointermove" id="badge-move">pointermove</div>
          <div class="event-badge pointerdown" id="badge-down">pointerdown</div>
          <div class="event-badge pointerup" id="badge-up">pointerup</div>
        </div>
        
        <!-- Status Overlay -->
        <div class="overlay status">
          <div class="status-row">
            <span>Input:</span>
            <span class="status-value green" id="inputStatus">Mouse</span>
          </div>
          <div class="status-row">
            <span>Smoother:</span>
            <span class="status-value accent" id="smootherStatus">1‚Ç¨ Filter</span>
          </div>
          <div class="status-row">
            <span>Pipeline:</span>
            <span class="status-value green">REAL</span>
          </div>
        </div>
        
        <!-- Metrics Overlay -->
        <div class="overlay metrics">
          <div class="status-row">
            <span>Raw:</span>
            <span class="status-value" id="rawPos">0, 0</span>
          </div>
          <div class="status-row">
            <span>Smoothed:</span>
            <span class="status-value green" id="smoothedPos">0, 0</span>
          </div>
          <div class="status-row">
            <span>Events/sec:</span>
            <span class="status-value accent" id="eventsPerSec">0</span>
          </div>
          <div class="status-row">
            <span>FPS:</span>
            <span class="status-value" id="fps">60</span>
          </div>
        </div>
        
        <!-- FSM Indicator -->
        <div class="fsm-indicator">
          <div class="fsm-dot DISARMED" id="fsmDot"></div>
          <div>
            <div class="fsm-state-text" id="fsmStateText">DISARMED</div>
            <div class="fsm-message" id="fsmMessage">Waiting for input</div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Sidebar -->
    <div class="sidebar">
      <!-- Smoother Selection -->
      <div class="panel">
        <h3>
          „Ä∞Ô∏è Smoother Selection
          <span class="tag">HOT-SWAP</span>
        </h3>
        <div class="smoother-tabs">
          <button class="smoother-tab active" data-smoother="oneeuro">1‚Ç¨ Filter</button>
          <button class="smoother-tab" data-smoother="rapier">Physics</button>
          <button class="smoother-tab" data-smoother="desp">DESP</button>
        </div>
        
        <!-- 1‚Ç¨ Filter Controls -->
        <div class="smoother-panel active" id="oneEuroPanel">
          <div class="control-row">
            <label>Min Cutoff <span class="source">@CHI2012</span></label>
            <input type="range" id="mincutoff" min="0.1" max="10" step="0.1" value="1.0">
            <span class="val" id="mincutoffVal">1.0</span>
          </div>
          <div class="control-row">
            <label>Beta <span class="source">@CHI2012</span></label>
            <input type="range" id="beta" min="0" max="1" step="0.001" value="0.007">
            <span class="val" id="betaVal">0.007</span>
          </div>
        </div>
        
        <!-- Rapier Physics Controls -->
        <div class="smoother-panel" id="rapierPanel">
          <div class="control-row">
            <label>Stiffness <span class="source">@HFO</span></label>
            <input type="range" id="stiffness" min="100" max="500" step="10" value="200">
            <span class="val" id="stiffnessVal">200</span>
          </div>
          <div class="control-row">
            <label>Damping <span class="source">@HFO</span></label>
            <input type="range" id="damping" min="0.5" max="2.0" step="0.1" value="1.2">
            <span class="val" id="dampingVal">1.2</span>
          </div>
          <div class="control-row">
            <label>Dead Zone <span class="source">@XInput</span></label>
            <input type="range" id="deadzone" min="0.05" max="0.25" step="0.01" value="0.10">
            <span class="val" id="deadzoneVal">0.10</span>
          </div>
        </div>
        
        <!-- DESP Controls -->
        <div class="smoother-panel" id="despPanel">
          <div class="control-row">
            <label>Alpha <span class="source">@LaViola03</span></label>
            <input type="range" id="despAlpha" min="0.1" max="0.9" step="0.05" value="0.5">
            <span class="val" id="despAlphaVal">0.5</span>
          </div>
          <div class="control-row">
            <label>Predict ms <span class="source">@LaViola03</span></label>
            <input type="range" id="despPredict" min="0" max="100" step="5" value="50">
            <span class="val" id="despPredictVal">50</span>
          </div>
        </div>
      </div>
      
      <!-- FSM States Reference -->
      <div class="panel">
        <h3>üîÑ FSM States</h3>
        <div style="font-size: 0.8rem;">
          <div class="control-row">
            <span style="display: flex; align-items: center; gap: 6px;">
              <span style="width: 10px; height: 10px; border-radius: 50%; background: var(--red);"></span>
              DISARMED
            </span>
            <span class="log-coords">Waiting for input</span>
          </div>
          <div class="control-row">
            <span style="display: flex; align-items: center; gap: 6px;">
              <span style="width: 10px; height: 10px; border-radius: 50%; background: var(--yellow);"></span>
              ARMING
            </span>
            <span class="log-coords">Stabilizing...</span>
          </div>
          <div class="control-row">
            <span style="display: flex; align-items: center; gap: 6px;">
              <span style="width: 10px; height: 10px; border-radius: 50%; background: var(--green);"></span>
              ARMED
            </span>
            <span class="log-coords">Move cursor</span>
          </div>
          <div class="control-row">
            <span style="display: flex; align-items: center; gap: 6px;">
              <span style="width: 10px; height: 10px; border-radius: 50%; background: var(--accent);"></span>
              DOWN_COMMIT
            </span>
            <span class="log-coords">Pointer DOWN</span>
          </div>
        </div>
      </div>
      
      <!-- W3C Event Log -->
      <div class="panel">
        <h3>üì° W3C Event Log</h3>
        <div class="event-log" id="eventLog">
          <div class="log-entry">
            <span class="log-type">--</span>
            <span class="log-coords">Waiting...</span>
          </div>
        </div>
      </div>
      
      <!-- Architecture -->
      <div class="panel">
        <h3>üèóÔ∏è Pipeline Architecture</h3>
        <div style="font-size: 0.7rem; color: var(--text-dim); line-height: 1.8;">
          <div>üì• Input (Mouse/Camera)</div>
          <div style="padding-left: 12px;">‚Üì Raw Position</div>
          <div style="color: var(--green);">„Ä∞Ô∏è SmootherPort (SHAPE)</div>
          <div style="padding-left: 12px;">‚Üì Smoothed Position</div>
          <div style="color: var(--purple);">üîÑ FSM (DELIVER)</div>
          <div style="padding-left: 12px;">‚Üì State Transitions</div>
          <div style="color: var(--accent);">üéØ W3C PointerEvents</div>
        </div>
      </div>
    </div>
  </main>
  
  <footer>
    <div>HFO Gen87.X3 | <a href="index.html">‚Üê All Demos</a></div>
    <div>Camera‚ÜíMediaPipe‚ÜíSmoother‚ÜíFSM‚ÜíW3C</div>
  </footer>

  <script type="module">
    // ============================================================================
    // IMPORT REAL HFO ADAPTERS (Built from TypeScript)
    // ============================================================================
    import {
      // Constants
      ONE_EURO_MINCUTOFF_DEFAULT,
      ONE_EURO_BETA_DEFAULT,
      RAPIER_STIFFNESS_DEFAULT,
      RAPIER_DAMPING_DEFAULT,
      DEAD_ZONE_DEFAULT,
      
      // Smoother Adapters
      OneEuroExemplarAdapter,
      RapierPhysicsAdapter,
      DoubleExponentialPredictor,
      
      // FSM Gates
      calculatePalmAngle,
      createPalmConeGateState,
      updatePalmConeGate,
      DEFAULT_PALM_CONE_CONFIG,
      createGestureTransitionState,
      updateGestureTransitionPredictor,
      DEFAULT_GESTURE_TRANSITION_CONFIG,
      
      // Helpers
      createSensorFrameFromMouse,
      addJitter,
      
      // TLA
      __tla,
    } from './lib/hfo.js';
    
    // Wait for async module initialization (REQUIRED)
    await __tla;
    
    console.log('‚úÖ HFO E2E Pipeline Loaded');
    console.log('   - Smoothers: OneEuro, Rapier, DESP');
    console.log('   - FSM: Palm Cone Gate + Gesture Predictor');
    
    // ============================================================================
    // STATE
    // ============================================================================
    let inputMode = 'mouse';
    let currentSmootherType = 'oneeuro';
    let mouseX = 0.5, mouseY = 0.5;
    let isMouseDown = false;
    
    // FSM State
    let fsmState = 'DISARMED';
    let palmGateState = createPalmConeGateState();
    let gestureState = createGestureTransitionState();
    let armingStartTime = null;
    const ARM_STABLE_MS = 200;
    
    // Metrics
    let eventCount = 0;
    let lastEventCountTime = performance.now();
    let eventsPerSecond = 0;
    let frameCount = 0;
    let lastFpsTime = 0;
    
    // MediaPipe (using GestureRecognizer)
    let lastLandmarks = null;
    
    // ============================================================================
    // SMOOTHER INSTANCES
    // ============================================================================
    let oneEuroSmoother = null;
    let rapierSmoother = null;
    let despSmoother = null;
    
    async function initSmoothers() {
      try {
        // 1‚Ç¨ Filter - REAL npm package
        oneEuroSmoother = new OneEuroExemplarAdapter({
          frequency: 60,
          minCutoff: ONE_EURO_MINCUTOFF_DEFAULT,
          beta: ONE_EURO_BETA_DEFAULT,
        });
        console.log('‚úÖ OneEuroExemplarAdapter initialized');
        
        // Rapier Physics - REAL WASM
        rapierSmoother = new RapierPhysicsAdapter({
          mode: 'smoothed',
          stiffness: RAPIER_STIFFNESS_DEFAULT,
          damping: RAPIER_DAMPING_DEFAULT,
          velocityDeadZone: DEAD_ZONE_DEFAULT,
        });
        console.log('‚úÖ RapierPhysicsAdapter initialized');
        
        // DESP - LaViola 2003
        despSmoother = new DoubleExponentialPredictor({
          alpha: 0.5,
          predictionMs: 50,
          clampOutput: true,
        });
        console.log('‚úÖ DoubleExponentialPredictor initialized');
        
        document.getElementById('loadingOverlay').style.display = 'none';
      } catch (err) {
        console.error('Failed to initialize smoothers:', err);
        document.getElementById('loadingOverlay').innerHTML = `
          <div style="color: var(--red)">‚ùå Failed: ${err.message}</div>
        `;
      }
    }
    
    function getCurrentSmoother() {
      switch (currentSmootherType) {
        case 'oneeuro': return oneEuroSmoother;
        case 'rapier': return rapierSmoother;
        case 'desp': return despSmoother;
        default: return oneEuroSmoother;
      }
    }
    
    // ============================================================================
    // FSM LOGIC (Inline Simplified)
    // ============================================================================
    const FSM_MESSAGES = {
      DISARMED: 'Waiting for input',
      ARMING: 'Stabilizing...',
      ARMED: 'Tracking - Move cursor',
      DOWN_COMMIT: 'Pointer DOWN',
    };
    
    function updateFSM(x, y, isDown, timestamp) {
      const prevState = fsmState;
      let w3cEvent = null;
      
      // For mouse mode, simulate simplified FSM
      // In camera mode, this would use palm cone + gesture detection
      
      if (inputMode === 'mouse') {
        // Mouse mode: Simplified FSM based on mouse position and button
        const inBounds = x >= 0 && x <= 1 && y >= 0 && y <= 1;
        
        switch (fsmState) {
          case 'DISARMED':
            if (inBounds) {
              fsmState = 'ARMING';
              armingStartTime = timestamp;
            }
            break;
            
          case 'ARMING':
            if (!inBounds) {
              fsmState = 'DISARMED';
              armingStartTime = null;
            } else if (timestamp - armingStartTime >= ARM_STABLE_MS) {
              fsmState = 'ARMED';
              w3cEvent = createW3CEvent('pointermove', x, y, 0);
            }
            break;
            
          case 'ARMED':
            if (!inBounds) {
              fsmState = 'DISARMED';
              w3cEvent = createW3CEvent('pointercancel', x, y, 0);
            } else if (isDown) {
              fsmState = 'DOWN_COMMIT';
              w3cEvent = createW3CEvent('pointerdown', x, y, 1);
            } else {
              w3cEvent = createW3CEvent('pointermove', x, y, 0);
            }
            break;
            
          case 'DOWN_COMMIT':
            if (!inBounds) {
              fsmState = 'DISARMED';
              w3cEvent = createW3CEvent('pointercancel', x, y, 0);
            } else if (!isDown) {
              fsmState = 'ARMED';
              w3cEvent = createW3CEvent('pointerup', x, y, 0);
            } else {
              w3cEvent = createW3CEvent('pointermove', x, y, 1);
            }
            break;
        }
      } else {
        // Camera mode: Would use real palm cone gate and gesture predictor
        // For now, similar logic with landmarks
        if (lastLandmarks) {
          const palmAngle = calculatePalmAngle(lastLandmarks);
          const gateResult = updatePalmConeGate(palmAngle, timestamp, palmGateState, DEFAULT_PALM_CONE_CONFIG);
          palmGateState = gateResult.state;
          
          const isFacing = gateResult.isFacing;
          const shouldCancel = gateResult.shouldCancel;
          
          if (shouldCancel && fsmState !== 'DISARMED') {
            fsmState = 'DISARMED';
            w3cEvent = createW3CEvent('pointercancel', x, y, 0);
          } else {
            switch (fsmState) {
              case 'DISARMED':
                if (isFacing) {
                  fsmState = 'ARMING';
                  armingStartTime = timestamp;
                }
                break;
                
              case 'ARMING':
                if (!isFacing) {
                  fsmState = 'DISARMED';
                } else if (timestamp - armingStartTime >= ARM_STABLE_MS) {
                  fsmState = 'ARMED';
                  w3cEvent = createW3CEvent('pointermove', x, y, 0);
                }
                break;
                
              case 'ARMED':
                if (!isFacing) {
                  fsmState = 'DISARMED';
                  w3cEvent = createW3CEvent('pointercancel', x, y, 0);
                } else {
                  w3cEvent = createW3CEvent('pointermove', x, y, 0);
                }
                break;
            }
          }
        }
      }
      
      // Update FSM display
      updateFSMDisplay();
      
      return w3cEvent;
    }
    
    function createW3CEvent(type, x, y, buttons) {
      const targetArea = document.getElementById('targetArea');
      const rect = targetArea.getBoundingClientRect();
      
      return new PointerEvent(type, {
        bubbles: true,
        cancelable: true,
        pointerId: 1,
        pointerType: inputMode === 'mouse' ? 'mouse' : 'touch',
        isPrimary: true,
        clientX: rect.left + x * rect.width,
        clientY: rect.top + y * rect.height,
        button: type === 'pointerdown' ? 0 : -1,
        buttons: buttons,
        pressure: buttons > 0 ? 0.5 : 0,
      });
    }
    
    function updateFSMDisplay() {
      const dot = document.getElementById('fsmDot');
      const text = document.getElementById('fsmStateText');
      const message = document.getElementById('fsmMessage');
      const stripValue = document.getElementById('fsmStateStrip');
      
      dot.className = `fsm-dot ${fsmState}`;
      text.textContent = fsmState;
      message.textContent = FSM_MESSAGES[fsmState];
      stripValue.textContent = fsmState;
      
      // Update pipeline stage
      document.getElementById('stage-fsm').classList.toggle('active', fsmState !== 'DISARMED');
    }
    
    // ============================================================================
    // EVENT DISPATCH & LOGGING
    // ============================================================================
    const eventLog = document.getElementById('eventLog');
    const maxLogEntries = 50;
    
    function dispatchW3CEvent(event) {
      if (!event) return;
      
      const targetArea = document.getElementById('targetArea');
      targetArea.dispatchEvent(event);
      
      // Update metrics
      eventCount++;
      
      // Log event
      logEvent(event);
      
      // Update pipeline strip
      document.getElementById('lastEventType').textContent = event.type;
      document.getElementById('stage-output').classList.add('active');
      setTimeout(() => {
        document.getElementById('stage-output').classList.remove('active');
      }, 100);
      
      // Flash event badge
      flashBadge(event.type);
    }
    
    function logEvent(event) {
      const entry = document.createElement('div');
      entry.className = `log-entry ${event.type}`;
      entry.innerHTML = `
        <span class="log-type">${event.type}</span>
        <span class="log-coords">${Math.round(event.clientX)}, ${Math.round(event.clientY)}</span>
      `;
      
      eventLog.insertBefore(entry, eventLog.firstChild);
      
      // Trim old entries
      while (eventLog.children.length > maxLogEntries) {
        eventLog.removeChild(eventLog.lastChild);
      }
    }
    
    function flashBadge(type) {
      const badgeMap = {
        pointermove: 'badge-move',
        pointerdown: 'badge-down',
        pointerup: 'badge-up',
      };
      
      const badgeId = badgeMap[type];
      if (badgeId) {
        const badge = document.getElementById(badgeId);
        badge.classList.add('show');
        setTimeout(() => badge.classList.remove('show'), 300);
      }
    }
    
    // ============================================================================
    // CROSSHAIR & TARGET HANDLING
    // ============================================================================
    const crosshair = document.getElementById('crosshair');
    const targetArea = document.getElementById('targetArea');
    
    function updateCrosshair(x, y, isDown) {
      const rect = targetArea.getBoundingClientRect();
      crosshair.style.left = `${x * rect.width}px`;
      crosshair.style.top = `${y * rect.height}px`;
      crosshair.classList.toggle('down', isDown);
    }
    
    // Target responds to pointer events
    targetArea.addEventListener('pointermove', (e) => {
      // Visual response could be added here
    });
    
    targetArea.addEventListener('pointerdown', (e) => {
      targetArea.style.background = 'rgba(88, 166, 255, 0.1)';
    });
    
    targetArea.addEventListener('pointerup', (e) => {
      targetArea.style.background = '#010409';
    });
    
    targetArea.addEventListener('pointercancel', (e) => {
      targetArea.style.background = '#010409';
    });
    
    // ============================================================================
    // MOUSE INPUT
    // ============================================================================
    targetArea.addEventListener('mousemove', (e) => {
      if (inputMode !== 'mouse') return;
      const rect = targetArea.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) / rect.width;
      mouseY = (e.clientY - rect.top) / rect.height;
    });
    
    targetArea.addEventListener('mousedown', (e) => {
      if (inputMode !== 'mouse') return;
      isMouseDown = true;
    });
    
    targetArea.addEventListener('mouseup', (e) => {
      if (inputMode !== 'mouse') return;
      isMouseDown = false;
    });
    
    targetArea.addEventListener('mouseleave', (e) => {
      if (inputMode !== 'mouse') return;
      mouseX = -1;
      mouseY = -1;
    });
    
    targetArea.addEventListener('mouseenter', (e) => {
      if (inputMode !== 'mouse') return;
      const rect = targetArea.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) / rect.width;
      mouseY = (e.clientY - rect.top) / rect.height;
    });
    
    // ============================================================================
    // MEDIAPIPE CAMERA INPUT
    // ============================================================================
    let gestureRecognizer = null;
    let filesetResolver = null;
    
    async function initMediaPipe() {
      try {
        // Use GestureRecognizer from CDN (TRL 9 - Google production ML)
        const vision = await import('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/vision_bundle.mjs');
        
        filesetResolver = await vision.FilesetResolver.forVisionTasks(
          'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.8/wasm'
        );
        
        gestureRecognizer = await vision.GestureRecognizer.createFromOptions(filesetResolver, {
          baseOptions: {
            modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task',
            delegate: 'GPU'
          },
          runningMode: 'VIDEO',
          numHands: 1,
          minHandDetectionConfidence: 0.7,
          minTrackingConfidence: 0.5
        });
        
        console.log('‚úÖ MediaPipe GestureRecognizer initialized (CDN)');
      } catch (err) {
        console.warn('MediaPipe not available:', err.message);
      }
    }
    
    function processMediaPipeFrame(video, timestamp) {
      if (!gestureRecognizer) return;
      
      try {
        const results = gestureRecognizer.recognizeForVideo(video, timestamp);
        
        if (results.landmarks && results.landmarks.length > 0) {
          lastLandmarks = results.landmarks[0];
          
          // Use index fingertip (landmark 8) for position
          const indexTip = lastLandmarks[8];
          mouseX = indexTip.x;
          mouseY = indexTip.y;
          
          // Store gesture data for telemetry
          if (results.gestures && results.gestures.length > 0) {
            const gesture = results.gestures[0][0];
            window.__lastGesture = {
              label: gesture.categoryName,
              confidence: gesture.score,
              handedness: results.handednesses?.[0]?.[0]?.categoryName || 'Unknown',
            };
          }
        } else {
          lastLandmarks = null;
          window.__lastGesture = null;
        }
      } catch (err) {
        // Silent fail - common during initialization
      }
    }
    
    async function startCamera() {
      try {
        const video = document.createElement('video');
        video.style.display = 'none';
        document.body.appendChild(video);
        
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { width: 640, height: 480 }
        });
        video.srcObject = stream;
        await video.play();
        
        // Process frames using GestureRecognizer
        function processFrame() {
          if (inputMode === 'camera' && gestureRecognizer) {
            processMediaPipeFrame(video, performance.now());
          }
          requestAnimationFrame(processFrame);
        }
        processFrame();
        
        console.log('‚úÖ Camera started');
      } catch (err) {
        console.error('Camera error:', err);
        alert('Camera access denied. Falling back to mouse input.');
        inputMode = 'mouse';
        updateInputMode();
      }
    }
    
    function updateInputMode() {
      document.querySelectorAll('.input-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.input === inputMode);
      });
      document.getElementById('inputType').textContent = inputMode === 'mouse' ? 'Mouse' : 'Camera';
      document.getElementById('inputStatus').textContent = inputMode === 'mouse' ? 'Mouse' : 'Camera';
      
      // Reset FSM when switching modes
      fsmState = 'DISARMED';
      palmGateState = createPalmConeGateState();
      gestureState = createGestureTransitionState();
      updateFSMDisplay();
    }
    
    // ============================================================================
    // CONTROLS
    // ============================================================================
    // Input mode
    document.querySelectorAll('.input-btn').forEach(btn => {
      btn.addEventListener('click', async () => {
        inputMode = btn.dataset.input;
        updateInputMode();
        
        if (inputMode === 'camera') {
          await initMediaPipe();
          await startCamera();
        }
      });
    });
    
    // Smoother tabs
    document.querySelectorAll('.smoother-tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.smoother-tab').forEach(t => t.classList.remove('active'));
        document.querySelectorAll('.smoother-panel').forEach(p => p.classList.remove('active'));
        tab.classList.add('active');
        currentSmootherType = tab.dataset.smoother;
        
        const panelId = currentSmootherType === 'oneeuro' ? 'oneEuroPanel' :
                        currentSmootherType === 'rapier' ? 'rapierPanel' : 'despPanel';
        document.getElementById(panelId).classList.add('active');
        
        const smootherName = currentSmootherType === 'oneeuro' ? '1‚Ç¨ Filter' :
                            currentSmootherType === 'rapier' ? 'Rapier Physics' : 'DESP';
        document.getElementById('smootherType').textContent = 
          currentSmootherType === 'oneeuro' ? '1‚Ç¨' :
          currentSmootherType === 'rapier' ? 'Physics' : 'DESP';
        document.getElementById('smootherStatus').textContent = smootherName;
        
        // Reset smoother
        const smoother = getCurrentSmoother();
        if (smoother) smoother.reset();
      });
    });
    
    // 1‚Ç¨ Filter controls
    document.getElementById('mincutoff').addEventListener('input', (e) => {
      document.getElementById('mincutoffVal').textContent = parseFloat(e.target.value).toFixed(1);
      if (oneEuroSmoother) {
        oneEuroSmoother.setParams(parseFloat(e.target.value), parseFloat(document.getElementById('beta').value));
      }
    });
    
    document.getElementById('beta').addEventListener('input', (e) => {
      document.getElementById('betaVal').textContent = parseFloat(e.target.value).toFixed(3);
      if (oneEuroSmoother) {
        oneEuroSmoother.setParams(parseFloat(document.getElementById('mincutoff').value), parseFloat(e.target.value));
      }
    });
    
    // Rapier controls
    ['stiffness', 'damping', 'deadzone'].forEach(id => {
      document.getElementById(id).addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        document.getElementById(`${id}Val`).textContent = id === 'deadzone' ? val.toFixed(2) : val.toFixed(1);
      });
    });
    
    // DESP controls
    ['despAlpha', 'despPredict'].forEach(id => {
      document.getElementById(id).addEventListener('input', (e) => {
        const val = parseFloat(e.target.value);
        document.getElementById(`${id}Val`).textContent = id === 'despAlpha' ? val.toFixed(2) : val.toFixed(0);
      });
    });
    
    // ============================================================================
    // MAIN RENDER LOOP
    // ============================================================================
    let telemetryFrameIndex = 0;
    const TELEMETRY_SAMPLE_RATE = 3; // Emit every Nth frame to reduce noise
    
    function render(timestamp) {
      frameCount++;
      const prevFsmState = fsmState;
      
      // FPS calculation
      if (timestamp - lastFpsTime > 500) {
        document.getElementById('fps').textContent = Math.round(frameCount * 2).toString();
        frameCount = 0;
        lastFpsTime = timestamp;
      }
      
      // Events per second
      if (timestamp - lastEventCountTime > 1000) {
        eventsPerSecond = eventCount;
        eventCount = 0;
        lastEventCountTime = timestamp;
        document.getElementById('eventsPerSec').textContent = eventsPerSecond.toString();
      }
      
      // Skip if out of bounds (mouse left area)
      if (mouseX < 0 || mouseY < 0) {
        requestAnimationFrame(render);
        return;
      }
      
      // Update raw position display
      document.getElementById('rawPos').textContent = 
        `${(mouseX * 100).toFixed(1)}%, ${(mouseY * 100).toFixed(1)}%`;
      
      // Create sensor frame
      const sensorFrame = createSensorFrameFromMouse(mouseX, mouseY, timestamp);
      
      // Apply smoothing
      const smoother = getCurrentSmoother();
      let smoothedX = mouseX;
      let smoothedY = mouseY;
      
      if (smoother) {
        try {
          const smoothedFrame = smoother.smooth(sensorFrame);
          smoothedX = smoothedFrame?.position?.x ?? mouseX;
          smoothedY = smoothedFrame?.position?.y ?? mouseY;
        } catch (err) {
          console.error('Smoother error:', err);
        }
      }
      
      // Update smoothed position display
      document.getElementById('smoothedPos').textContent = 
        `${(smoothedX * 100).toFixed(1)}%, ${(smoothedY * 100).toFixed(1)}%`;
      
      // Update pipeline smoother stage
      document.getElementById('stage-smoother').classList.add('active');
      
      // Update crosshair
      updateCrosshair(smoothedX, smoothedY, fsmState === 'DOWN_COMMIT');
      
      // Run FSM and dispatch events
      const w3cEvent = updateFSM(smoothedX, smoothedY, isMouseDown, timestamp);
      if (w3cEvent) {
        dispatchW3CEvent(w3cEvent);
      }
      
      // ============================================================================
      // TELEMETRY EMISSION (For Golden Master Testing)
      // ============================================================================
      if (window.__telemetry && telemetryFrameIndex % TELEMETRY_SAMPLE_RATE === 0) {
        // Calculate palm angle if we have landmarks
        let palmAngleData = null;
        if (lastLandmarks && inputMode === 'camera') {
          try {
            const palmAngleDegrees = calculatePalmAngle(lastLandmarks);
            palmAngleData = {
              degrees: palmAngleDegrees,
              isFacing: palmAngleDegrees <= DEFAULT_PALM_CONE_CONFIG.armThresholdDegrees,
              shouldCancel: palmAngleDegrees >= DEFAULT_PALM_CONE_CONFIG.cancelThresholdDegrees,
            };
          } catch (e) { /* ignore */ }
        }
        
        window.__telemetry.recordFrame({
          timestamp,
          inputSource: inputMode,
          position: { x: mouseX, y: mouseY },
          smoothed: { type: currentSmootherType, x: smoothedX, y: smoothedY },
          gesture: window.__lastGesture || null,
          palmAngle: palmAngleData,
          fsm: {
            previous: prevFsmState,
            current: fsmState,
            transition: prevFsmState !== fsmState ? `${prevFsmState}‚Üí${fsmState}` : null,
          },
          w3cEvent: w3cEvent ? {
            type: w3cEvent.type,
            clientX: w3cEvent.clientX,
            clientY: w3cEvent.clientY,
            buttons: w3cEvent.buttons,
            pressure: w3cEvent.pressure,
          } : null,
        });
      }
      telemetryFrameIndex++;
      
      requestAnimationFrame(render);
    }
    
    // ============================================================================
    // INITIALIZATION
    // ============================================================================
    initSmoothers().then(() => {
      updateFSMDisplay();
      requestAnimationFrame(render);
      console.log('üöÄ E2E Pipeline Variant B ready');
    });
  </script>
</body>
</html>
