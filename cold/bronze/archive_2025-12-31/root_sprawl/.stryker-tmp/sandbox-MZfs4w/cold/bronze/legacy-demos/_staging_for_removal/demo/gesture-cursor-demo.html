<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gen87.X3 Gesture Cursor Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            overflow: hidden;
        }

        .header {
            padding: 20px;
            text-align: center;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 2px solid #e94560;
        }

        .header h1 {
            color: #e94560;
            font-size: 2rem;
            margin-bottom: 5px;
        }

        .header .subtitle {
            color: #888;
            font-size: 0.9rem;
        }

        .main-container {
            display: flex;
            height: calc(100vh - 100px);
        }

        /* Left Panel - Status */
        .status-panel {
            width: 300px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.2);
            border-right: 1px solid #333;
        }

        .status-section {
            margin-bottom: 20px;
        }

        .status-section h3 {
            color: #e94560;
            margin-bottom: 10px;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #333;
        }

        .status-item .label {
            color: #888;
        }

        .status-item .value {
            font-family: 'Consolas', monospace;
            color: #4ade80;
        }

        .status-item .value.warning {
            color: #fbbf24;
        }

        .status-item .value.error {
            color: #ef4444;
        }

        /* FSM State Indicator */
        .fsm-state {
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 20px;
        }

        .fsm-state.DISARMED {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid #ef4444;
            color: #ef4444;
        }

        .fsm-state.ARMING {
            background: rgba(251, 191, 36, 0.2);
            border: 2px solid #fbbf24;
            color: #fbbf24;
        }

        .fsm-state.ARMED {
            background: rgba(74, 222, 128, 0.2);
            border: 2px solid #4ade80;
            color: #4ade80;
        }

        .fsm-state.DOWN_COMMIT {
            background: rgba(96, 165, 250, 0.2);
            border: 2px solid #60a5fa;
            color: #60a5fa;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #gesture-canvas {
            width: 100%;
            height: 100%;
            cursor: none;
        }

        /* Custom Cursor */
        .gesture-cursor {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: all 0.05s ease-out;
            z-index: 1000;
        }

        .gesture-cursor.DISARMED {
            background: rgba(239, 68, 68, 0.3);
            border: 3px solid #ef4444;
        }

        .gesture-cursor.ARMING {
            background: rgba(251, 191, 36, 0.3);
            border: 3px solid #fbbf24;
            animation: pulse 0.5s ease-in-out infinite;
        }

        .gesture-cursor.ARMED {
            background: rgba(74, 222, 128, 0.3);
            border: 3px solid #4ade80;
        }

        .gesture-cursor.DOWN_COMMIT {
            background: rgba(96, 165, 250, 0.5);
            border: 3px solid #60a5fa;
            transform: translate(-50%, -50%) scale(0.8);
        }

        .cursor-trail {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(233, 69, 96, 0.5);
            pointer-events: none;
            transform: translate(-50%, -50%);
        }

        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }

        /* Click Targets */
        .click-target {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .click-target:hover {
            transform: scale(1.05);
        }

        .click-target.clicked {
            animation: click-flash 0.3s ease-out;
        }

        @keyframes click-flash {
            0% { transform: scale(1); filter: brightness(1); }
            50% { transform: scale(0.95); filter: brightness(1.5); }
            100% { transform: scale(1); filter: brightness(1); }
        }

        .click-target.red { background: #ef4444; top: 20%; left: 20%; }
        .click-target.green { background: #4ade80; top: 20%; right: 20%; }
        .click-target.blue { background: #60a5fa; bottom: 20%; left: 20%; }
        .click-target.yellow { background: #fbbf24; color: #000; bottom: 20%; right: 20%; }
        .click-target.center { 
            background: #e94560; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%);
            width: 120px;
            height: 120px;
            border-radius: 50%;
        }

        /* Event Log */
        .event-log {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            max-height: 150px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 8px;
            padding: 10px;
            font-family: 'Consolas', monospace;
            font-size: 0.75rem;
        }

        .event-log .event {
            padding: 3px 0;
            border-bottom: 1px solid #333;
        }

        .event-log .event.move { color: #888; }
        .event-log .event.down { color: #60a5fa; }
        .event-log .event.up { color: #4ade80; }
        .event-log .event.click { color: #e94560; }

        /* Simulation Controls */
        .controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
        }

        .control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .control-btn.primary {
            background: #e94560;
            color: white;
        }

        .control-btn.secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid #444;
        }

        .control-btn:hover {
            filter: brightness(1.1);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéØ Gen87.X3 Gesture Control Plane</h1>
        <div class="subtitle">W3C Pointer Events ‚Ä¢ XState FSM ‚Ä¢ Real Rapier WASM Physics</div>
    </div>

    <div class="main-container">
        <div class="status-panel">
            <div class="fsm-state DISARMED" id="fsm-state-display">DISARMED</div>

            <div class="status-section">
                <h3>üìç Cursor Position</h3>
                <div class="status-item">
                    <span class="label">X (normalized)</span>
                    <span class="value" id="pos-x">0.000</span>
                </div>
                <div class="status-item">
                    <span class="label">Y (normalized)</span>
                    <span class="value" id="pos-y">0.000</span>
                </div>
                <div class="status-item">
                    <span class="label">Viewport X</span>
                    <span class="value" id="viewport-x">0</span>
                </div>
                <div class="status-item">
                    <span class="label">Viewport Y</span>
                    <span class="value" id="viewport-y">0</span>
                </div>
            </div>

            <div class="status-section">
                <h3>üñ±Ô∏è Pointer Events</h3>
                <div class="status-item">
                    <span class="label">Event Type</span>
                    <span class="value" id="event-type">-</span>
                </div>
                <div class="status-item">
                    <span class="label">Pointer ID</span>
                    <span class="value" id="pointer-id">1</span>
                </div>
                <div class="status-item">
                    <span class="label">Pointer Type</span>
                    <span class="value" id="pointer-type">pen</span>
                </div>
                <div class="status-item">
                    <span class="label">Pressure</span>
                    <span class="value" id="pressure">0.0</span>
                </div>
            </div>

            <div class="status-section">
                <h3>üìä Statistics</h3>
                <div class="status-item">
                    <span class="label">Events/sec</span>
                    <span class="value" id="events-per-sec">0</span>
                </div>
                <div class="status-item">
                    <span class="label">Total Clicks</span>
                    <span class="value" id="total-clicks">0</span>
                </div>
                <div class="status-item">
                    <span class="label">Targets Hit</span>
                    <span class="value" id="targets-hit">0</span>
                </div>
            </div>
        </div>

        <div class="canvas-container" id="gesture-canvas">
            <div class="gesture-cursor DISARMED" id="gesture-cursor"></div>

            <!-- Click Targets -->
            <div class="click-target red" data-id="red">üî¥</div>
            <div class="click-target green" data-id="green">üü¢</div>
            <div class="click-target blue" data-id="blue">üîµ</div>
            <div class="click-target yellow" data-id="yellow">üü°</div>
            <div class="click-target center" data-id="center">CLICK</div>

            <div class="controls">
                <button class="control-btn primary" id="btn-simulate">‚ñ∂Ô∏è Simulate Click</button>
                <button class="control-btn secondary" id="btn-arm">üîì Toggle Arm</button>
                <button class="control-btn secondary" id="btn-reset">üîÑ Reset</button>
            </div>

            <div class="event-log" id="event-log"></div>
        </div>
    </div>

    <script type="module">
// @ts-nocheck

        // ============================================================================
        // SIMULATED W3C POINTER FACTORY (Browser Version)
        // ============================================================================

        class W3CPointerEventFactory {
            constructor(config = {}) {
                this.config = {
                    viewportWidth: config.viewportWidth || window.innerWidth,
                    viewportHeight: config.viewportHeight || window.innerHeight,
                    pointerId: config.pointerId || 1,
                    pointerType: config.pointerType || 'pen',
                    isPrimary: true,
                };
            }

            normalizedToViewport(normalized) {
                return {
                    clientX: Math.round(normalized.x * this.config.viewportWidth),
                    clientY: Math.round(normalized.y * this.config.viewportHeight),
                };
            }

            createEvent(type, init) {
                return new PointerEvent(type, {
                    bubbles: true,
                    cancelable: true,
                    composed: true,
                    pointerId: this.config.pointerId,
                    pointerType: this.config.pointerType,
                    isPrimary: this.config.isPrimary,
                    ...init,
                });
            }

            createMoveEvent(position) {
                const { clientX, clientY } = this.normalizedToViewport(position);
                return this.createEvent('pointermove', {
                    clientX, clientY,
                    screenX: clientX,
                    screenY: clientY,
                    button: -1,
                    buttons: 0,
                    pressure: 0,
                });
            }

            createDownEvent(position, pressure = 0.5) {
                const { clientX, clientY } = this.normalizedToViewport(position);
                return this.createEvent('pointerdown', {
                    clientX, clientY,
                    screenX: clientX,
                    screenY: clientY,
                    button: 0,
                    buttons: 1,
                    pressure,
                });
            }

            createUpEvent(position) {
                const { clientX, clientY } = this.normalizedToViewport(position);
                return this.createEvent('pointerup', {
                    clientX, clientY,
                    screenX: clientX,
                    screenY: clientY,
                    button: 0,
                    buttons: 0,
                    pressure: 0,
                });
            }

            fromFSMAction(action) {
                const events = [];
                switch (action.type) {
                    case 'MOVE':
                        events.push(this.createMoveEvent(action.position));
                        break;
                    case 'DOWN':
                        events.push(this.createDownEvent(action.position, action.pressure || 0.5));
                        break;
                    case 'UP':
                        events.push(this.createUpEvent(action.position));
                        break;
                    case 'CLICK':
                        events.push(this.createDownEvent(action.position, action.pressure || 0.5));
                        events.push(this.createUpEvent(action.position));
                        break;
                }
                return events;
            }
        }

        // ============================================================================
        // SIMPLE FSM (XState-like behavior)
        // ============================================================================

        const FSM_STATES = {
            DISARMED: 'DISARMED',
            ARMING: 'ARMING',
            ARMED: 'ARMED',
            DOWN_COMMIT: 'DOWN_COMMIT',
        };

        class GestureFSM {
            constructor() {
                this.state = FSM_STATES.DISARMED;
                this.armingTimer = null;
                this.armingDuration = 300; // ms
            }

            transition(event) {
                const prevState = this.state;

                switch (this.state) {
                    case FSM_STATES.DISARMED:
                        if (event === 'START_ARMING') {
                            this.state = FSM_STATES.ARMING;
                            this.startArmingTimer();
                        }
                        break;

                    case FSM_STATES.ARMING:
                        if (event === 'ARMING_COMPLETE') {
                            this.state = FSM_STATES.ARMED;
                        } else if (event === 'CANCEL') {
                            this.state = FSM_STATES.DISARMED;
                            this.clearArmingTimer();
                        }
                        break;

                    case FSM_STATES.ARMED:
                        if (event === 'COMMIT_START') {
                            this.state = FSM_STATES.DOWN_COMMIT;
                        } else if (event === 'DISARM') {
                            this.state = FSM_STATES.DISARMED;
                        }
                        break;

                    case FSM_STATES.DOWN_COMMIT:
                        if (event === 'COMMIT_END') {
                            this.state = FSM_STATES.ARMED;
                        } else if (event === 'DISARM') {
                            this.state = FSM_STATES.DISARMED;
                        }
                        break;
                }

                if (prevState !== this.state) {
                    this.onStateChange?.(this.state, prevState);
                }

                return this.state;
            }

            startArmingTimer() {
                this.armingTimer = setTimeout(() => {
                    this.transition('ARMING_COMPLETE');
                }, this.armingDuration);
            }

            clearArmingTimer() {
                if (this.armingTimer) {
                    clearTimeout(this.armingTimer);
                    this.armingTimer = null;
                }
            }
        }

        // ============================================================================
        // DEMO APPLICATION
        // ============================================================================

        class GestureDemo {
            constructor() {
                this.factory = new W3CPointerEventFactory();
                this.fsm = new GestureFSM();
                this.cursor = document.getElementById('gesture-cursor');
                this.canvas = document.getElementById('gesture-canvas');
                this.eventLog = document.getElementById('event-log');

                this.position = { x: 0.5, y: 0.5 };
                this.totalClicks = 0;
                this.targetsHit = 0;
                this.eventCount = 0;
                this.lastEventCountReset = Date.now();

                this.setupEventHandlers();
                this.setupFSM();
                this.setupControls();
                this.startEventRateCounter();
                this.updateCursorPosition();
            }

            setupEventHandlers() {
                // Track mouse for demo (simulates MediaPipe input)
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.position = {
                        x: (e.clientX - rect.left) / rect.width,
                        y: (e.clientY - rect.top) / rect.height,
                    };
                    this.updateCursorPosition();
                    this.updatePositionDisplay();

                    // Dispatch W3C pointer event
                    if (this.fsm.state === FSM_STATES.ARMED) {
                        const event = this.factory.createMoveEvent(this.position);
                        this.dispatchToTargets(event);
                        this.logEvent('move', event);
                    }
                });

                // Handle clicks on targets
                document.querySelectorAll('.click-target').forEach(target => {
                    target.addEventListener('pointerdown', (e) => {
                        if (e.pointerType === 'pen') {
                            target.classList.add('clicked');
                            this.targetsHit++;
                            document.getElementById('targets-hit').textContent = this.targetsHit;
                            setTimeout(() => target.classList.remove('clicked'), 300);
                        }
                    });
                });
            }

            setupFSM() {
                this.fsm.onStateChange = (newState, prevState) => {
                    this.updateFSMDisplay(newState);
                    this.cursor.className = `gesture-cursor ${newState}`;
                };
            }

            setupControls() {
                document.getElementById('btn-simulate').addEventListener('click', () => {
                    this.simulateClick();
                });

                document.getElementById('btn-arm').addEventListener('click', () => {
                    if (this.fsm.state === FSM_STATES.DISARMED) {
                        this.fsm.transition('START_ARMING');
                    } else {
                        this.fsm.transition('DISARM');
                    }
                });

                document.getElementById('btn-reset').addEventListener('click', () => {
                    this.fsm.transition('DISARM');
                    this.totalClicks = 0;
                    this.targetsHit = 0;
                    document.getElementById('total-clicks').textContent = 0;
                    document.getElementById('targets-hit').textContent = 0;
                    this.eventLog.innerHTML = '';
                });
            }

            simulateClick() {
                // Auto-arm if not armed
                if (this.fsm.state === FSM_STATES.DISARMED) {
                    this.fsm.transition('START_ARMING');
                    return;
                }

                if (this.fsm.state !== FSM_STATES.ARMED) return;

                // Transition to DOWN_COMMIT
                this.fsm.transition('COMMIT_START');

                // Create and dispatch click events
                const events = this.factory.fromFSMAction({
                    type: 'CLICK',
                    position: this.position,
                    state: 'clicking',
                });

                events.forEach(event => {
                    this.dispatchToTargets(event);
                    this.logEvent(event.type.replace('pointer', ''), event);
                });

                this.totalClicks++;
                document.getElementById('total-clicks').textContent = this.totalClicks;

                // Return to ARMED after short delay
                setTimeout(() => {
                    this.fsm.transition('COMMIT_END');
                }, 100);
            }

            dispatchToTargets(event) {
                // Find element under cursor
                const elements = document.elementsFromPoint(event.clientX, event.clientY);
                const target = elements.find(el => el.classList.contains('click-target'));

                if (target) {
                    target.dispatchEvent(new PointerEvent(event.type, event));
                }

                this.eventCount++;
            }

            updateCursorPosition() {
                const rect = this.canvas.getBoundingClientRect();
                const x = rect.left + this.position.x * rect.width;
                const y = rect.top + this.position.y * rect.height;
                this.cursor.style.left = `${x}px`;
                this.cursor.style.top = `${y}px`;
            }

            updatePositionDisplay() {
                document.getElementById('pos-x').textContent = this.position.x.toFixed(3);
                document.getElementById('pos-y').textContent = this.position.y.toFixed(3);
                const viewport = this.factory.normalizedToViewport(this.position);
                document.getElementById('viewport-x').textContent = viewport.clientX;
                document.getElementById('viewport-y').textContent = viewport.clientY;
            }

            updateFSMDisplay(state) {
                const display = document.getElementById('fsm-state-display');
                display.textContent = state;
                display.className = `fsm-state ${state}`;
            }

            logEvent(type, event) {
                const entry = document.createElement('div');
                entry.className = `event ${type}`;
                entry.textContent = `${new Date().toISOString().split('T')[1].slice(0, 12)} | ${event.type} @ (${event.clientX}, ${event.clientY})`;
                this.eventLog.insertBefore(entry, this.eventLog.firstChild);

                // Keep log size manageable
                while (this.eventLog.children.length > 50) {
                    this.eventLog.removeChild(this.eventLog.lastChild);
                }

                document.getElementById('event-type').textContent = event.type;
                document.getElementById('pressure').textContent = event.pressure.toFixed(2);
            }

            startEventRateCounter() {
                setInterval(() => {
                    const elapsed = (Date.now() - this.lastEventCountReset) / 1000;
                    const rate = Math.round(this.eventCount / elapsed);
                    document.getElementById('events-per-sec').textContent = rate;
                    this.eventCount = 0;
                    this.lastEventCountReset = Date.now();
                }, 1000);
            }
        }

        // Initialize demo
        const demo = new GestureDemo();
        console.log('üéØ Gen87.X3 Gesture Demo initialized');
    
</script>
</body>
</html>
