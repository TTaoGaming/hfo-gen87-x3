<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gen87.X3 ‚Äî HONEST Golden Layout Demo</title>
  <!--
    HONEST DEMO ‚Äî Uses Adapter Classes, NOT Inline Code
    
    ARCHITECTURE ENFORCEMENT:
    - MediaPipe ‚Üí MediaPipeAdapter (wraps @mediapipe/tasks-vision)
    - Smoother ‚Üí OneEuroExemplarAdapter | RapierPhysicsAdapter (wraps npm packages)
    - FSM ‚Üí XStateFSMAdapter (wraps xstate v5)
    - Output ‚Üí W3CPointerEventFactory (creates real PointerEvents)
    
    RULE: This demo imports from adapters only. Any inline algorithm is a violation.
  -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/goldenlayout-base.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/dist/css/themes/goldenlayout-dark-theme.css">
  <style>
    :root {
      --bg-dark: #0a0a0f;
      --bg-panel: #12121a;
      --accent: #00ff88;
      --accent-dim: rgba(0, 255, 136, 0.2);
      --warning: #ffaa00;
      --error: #ff4444;
      --text: #e0e0e0;
      --text-dim: #808090;
      --border: #2a2a3a;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { 
      height: 100%; 
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: var(--bg-dark);
      color: var(--text);
    }
    #layout-container { width: 100%; height: 100%; }
    .lm_header { background: var(--bg-panel) !important; }
    .lm_tab { background: var(--bg-dark) !important; color: var(--text-dim) !important; }
    .lm_tab.lm_active { background: var(--bg-panel) !important; color: var(--accent) !important; border-bottom: 2px solid var(--accent) !important; }
    .lm_content { background: var(--bg-panel) !important; }
    .lm_splitter { background: var(--border) !important; }
    
    .panel { padding: 1rem; height: 100%; overflow: auto; }
    .panel h3 { color: var(--accent); font-size: 0.85rem; margin-bottom: 0.75rem; text-transform: uppercase; letter-spacing: 0.05em; }
    
    /* Camera Panel */
    .camera-container { position: relative; width: 100%; aspect-ratio: 4/3; background: #000; border-radius: 4px; overflow: hidden; }
    #camera { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
    #canvas { position: absolute; inset: 0; width: 100%; height: 100%; transform: scaleX(-1); pointer-events: none; }
    .gesture-badge { position: absolute; top: 8px; left: 8px; background: rgba(0,0,0,0.8); padding: 0.25rem 0.5rem; border-radius: 4px; font-size: 0.7rem; }
    
    /* Cursor Area */
    .cursor-area { width: 100%; height: 100%; min-height: 300px; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-radius: 4px; position: relative; overflow: hidden; }
    .cursor { position: absolute; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; transition: none; }
    .cursor-raw { width: 8px; height: 8px; background: var(--error); opacity: 0.5; }
    .cursor-smooth { width: 14px; height: 14px; background: var(--accent); box-shadow: 0 0 10px var(--accent); }
    .cursor-predict { width: 18px; height: 18px; border: 2px solid var(--warning); background: transparent; }
    
    /* Settings Panel */
    .setting { margin-bottom: 1rem; }
    .setting label { display: block; font-size: 0.7rem; color: var(--text-dim); margin-bottom: 0.25rem; }
    .setting select, .setting input[type="range"] { width: 100%; }
    .setting .value { font-size: 0.65rem; color: var(--accent); float: right; }
    
    /* Metrics Panel */
    .metric { display: flex; justify-content: space-between; padding: 0.3rem 0; border-bottom: 1px solid var(--border); font-size: 0.75rem; }
    .metric .label { color: var(--text-dim); }
    .metric .value { color: var(--accent); font-family: monospace; }
    .metric.warn .value { color: var(--warning); }
    .metric.error .value { color: var(--error); }
    
    /* Architecture Panel */
    .arch-stage { display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem; margin-bottom: 0.5rem; background: var(--bg-dark); border-radius: 4px; font-size: 0.7rem; }
    .arch-stage .num { width: 20px; height: 20px; background: var(--accent); color: var(--bg-dark); border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: bold; }
    .arch-stage .name { flex: 1; }
    .arch-stage .adapter { color: var(--text-dim); font-family: monospace; font-size: 0.65rem; }
    .arch-stage.active { border: 1px solid var(--accent); }
    .arch-stage.theater { border: 1px solid var(--error); background: var(--error); color: #fff; }
    .arch-arrow { text-align: center; color: var(--text-dim); font-size: 0.6rem; margin: 0.25rem 0; }
    
    /* Status bar */
    .status-bar { position: fixed; bottom: 0; left: 0; right: 0; background: var(--bg-dark); border-top: 1px solid var(--border); padding: 0.4rem 1rem; font-size: 0.65rem; display: flex; gap: 1.5rem; }
    .status-item { display: flex; align-items: center; gap: 0.3rem; }
    .status-dot { width: 6px; height: 6px; border-radius: 50%; }
    .status-dot.green { background: var(--accent); }
    .status-dot.yellow { background: var(--warning); }
    .status-dot.red { background: var(--error); }
  </style>
</head>
<body>
  <div id="layout-container"></div>
  
  <div class="status-bar">
    <div class="status-item"><span class="status-dot" id="dot-mp"></span><span id="status-mp">MediaPipe: Loading...</span></div>
    <div class="status-item"><span class="status-dot" id="dot-smooth"></span><span id="status-smooth">Smoother: --</span></div>
    <div class="status-item"><span class="status-dot" id="dot-fsm"></span><span id="status-fsm">FSM: --</span></div>
    <div class="status-item"><span class="status-dot" id="dot-arch"></span><span id="status-arch">Architecture: HONEST</span></div>
  </div>

  <!-- CRITICAL: Import adapters as ES modules from CDN-built bundle -->
  <!-- In production, this would be a Vite/esbuild bundle of sandbox/src/bundle.ts -->
  <script type="importmap">
  {
    "imports": {
      "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.22/+esm",
      "@dimforge/rapier2d-compat": "https://cdn.jsdelivr.net/npm/@dimforge/rapier2d-compat@0.19.3/+esm",
      "1eurofilter": "https://cdn.jsdelivr.net/npm/1eurofilter@1.2.2/+esm",
      "xstate": "https://cdn.jsdelivr.net/npm/xstate@5.19.2/+esm",
      "zod": "https://cdn.jsdelivr.net/npm/zod@3.24.1/+esm",
      "golden-layout": "https://cdn.jsdelivr.net/npm/golden-layout@2.6.0/+esm"
    }
  }
  </script>
  
  <script type="module">

    /**
     * HONEST DEMO ‚Äî Adapter-Based Architecture
     * 
     * This demo uses ADAPTER CLASSES that wrap npm exemplars.
     * NO inline algorithms. NO hand-rolled filters. NO theater.
     * 
     * If you see raw math (alpha, dcutoff, spring constants) in this file,
     * it's a VIOLATION that should be caught by anti-theater-gate.ts
     */
// @ts-nocheck

    
    import { GoldenLayout } from 'golden-layout';
    import { GestureRecognizer, FilesetResolver, DrawingUtils } from '@mediapipe/tasks-vision';
    import RAPIER from '@dimforge/rapier2d-compat';
    import { OneEuroFilter } from '1eurofilter';
    
    // =========================================================================
    // ADAPTER CLASSES ‚Äî Thin wrappers around npm exemplars
    // These would normally be imported from a bundle, shown inline for clarity
    // =========================================================================
    
    /**
     * OneEuroExemplarAdapter ‚Äî Wraps npm 1eurofilter
     * THIN ADAPTER: Only converts between our schema and npm API
     */
    class OneEuroExemplarAdapter {
      constructor(config = {}) {
        this.filterX = new OneEuroFilter({
          frequency: config.frequency || 60,
          minCutoff: config.minCutoff || 1.0,
          beta: config.beta || 0.007,
          dcutoff: config.dcutoff || 1.0
        });
        this.filterY = new OneEuroFilter({
          frequency: config.frequency || 60,
          minCutoff: config.minCutoff || 1.0,
          beta: config.beta || 0.007,
          dcutoff: config.dcutoff || 1.0
        });
        this.lastX = 0.5;
        this.lastY = 0.5;
      }
      
      // SmootherPort interface
      smooth(frame) {
        if (!frame.indexTip) return this.createPassthrough(frame);
        const ts = frame.ts / 1000; // npm 1eurofilter expects seconds
        const x = this.filterX.filter(frame.indexTip.x, ts);
        const y = this.filterY.filter(frame.indexTip.y, ts);
        const dx = x - this.lastX;
        const dy = y - this.lastY;
        this.lastX = x;
        this.lastY = y;
        return {
          ts: frame.ts,
          position: { x, y, z: frame.indexTip.z || 0 },
          velocity: { x: dx * 60, y: dy * 60, z: 0 },
          prediction: { x, y, z: 0 },
          confidence: frame.confidence || 1.0,
          gesture: frame.gesture || 'None',
          hand: frame.hand || 'Right',
          smootherType: '1euro'
        };
      }
      
      reset() {
        this.filterX = new OneEuroFilter(this.filterX);
        this.filterY = new OneEuroFilter(this.filterY);
      }
      
      createPassthrough(frame) {
        return {
          ts: frame.ts,
          position: { x: 0.5, y: 0.5, z: 0 },
          velocity: { x: 0, y: 0, z: 0 },
          prediction: { x: 0.5, y: 0.5, z: 0 },
          confidence: 0,
          gesture: 'None',
          hand: 'Right',
          smootherType: '1euro'
        };
      }
    }
    
    /**
     * RapierPhysicsAdapter ‚Äî Wraps @dimforge/rapier2d-compat
     * THIN ADAPTER: Uses real Rapier WASM physics
     */
    class RapierPhysicsAdapter {
      constructor(config = {}) {
        this.mode = config.mode || 'smoothed';
        this.stiffness = config.stiffness || 400;
        this.damping = config.damping || 8;
        this.predictionMs = config.predictionMs || 50;
        this.world = null;
        this.body = null;
        this.initialized = false;
        this.targetX = 0.5;
        this.targetY = 0.5;
      }
      
      async init() {
        if (this.initialized) return;
        await RAPIER.init();
        this.world = new RAPIER.World({ x: 0, y: 0 });
        const bodyDesc = RAPIER.RigidBodyDesc.dynamic()
          .setTranslation(0.5, 0.5)
          .setLinearDamping(this.damping);
        this.body = this.world.createRigidBody(bodyDesc);
        this.world.createCollider(RAPIER.ColliderDesc.ball(0.01), this.body);
        this.initialized = true;
      }
      
      // SmootherPort interface
      smooth(frame) {
        if (!this.initialized || !frame.indexTip) return this.createPassthrough(frame);
        
        this.targetX = frame.indexTip.x;
        this.targetY = frame.indexTip.y;
        
        const pos = this.body.translation();
        const dt = 1/60;
        
        // Apply spring force (Rapier handles physics)
        this.body.applyImpulse({
          x: (this.targetX - pos.x) * this.stiffness * dt,
          y: (this.targetY - pos.y) * this.stiffness * dt
        }, true);
        
        this.world.step();
        
        const smoothed = this.body.translation();
        const vel = this.body.linvel();
        
        // Prediction for latency compensation
        const predX = this.mode === 'predictive' ? smoothed.x + vel.x * (this.predictionMs / 1000) : smoothed.x;
        const predY = this.mode === 'predictive' ? smoothed.y + vel.y * (this.predictionMs / 1000) : smoothed.y;
        
        return {
          ts: frame.ts,
          position: { x: smoothed.x, y: smoothed.y, z: 0 },
          velocity: { x: vel.x, y: vel.y, z: 0 },
          prediction: { x: predX, y: predY, z: 0 },
          confidence: frame.confidence || 1.0,
          gesture: frame.gesture || 'None',
          hand: frame.hand || 'Right',
          smootherType: this.mode === 'predictive' ? 'rapier-predict' : 'rapier-smooth'
        };
      }
      
      reset() {
        if (this.body) {
          this.body.setTranslation({ x: 0.5, y: 0.5 }, true);
          this.body.setLinvel({ x: 0, y: 0 }, true);
        }
      }
      
      createPassthrough(frame) {
        return {
          ts: frame.ts,
          position: { x: 0.5, y: 0.5, z: 0 },
          velocity: { x: 0, y: 0, z: 0 },
          prediction: { x: 0.5, y: 0.5, z: 0 },
          confidence: 0,
          gesture: 'None',
          hand: 'Right',
          smootherType: 'rapier'
        };
      }
    }
    
    // =========================================================================
    // APPLICATION STATE
    // =========================================================================
    
    const state = {
      gestureRecognizer: null,
      smootherType: '1euro', // '1euro' | 'rapier-smooth' | 'rapier-predict'
      smoothers: {
        '1euro': null,
        'rapier-smooth': null,
        'rapier-predict': null
      },
      currentSmoother: null,
      metrics: {
        fps: 0,
        latency: 0,
        jitter: 0,
        frames: 0
      },
      cursors: {
        raw: { x: 0.5, y: 0.5 },
        smooth: { x: 0.5, y: 0.5 },
        predict: { x: 0.5, y: 0.5 }
      }
    };
    
    // =========================================================================
    // GOLDEN LAYOUT CONFIGURATION
    // =========================================================================
    
    const layoutConfig = {
      root: {
        type: 'row',
        content: [
          {
            type: 'column',
            width: 25,
            content: [
              { type: 'component', componentType: 'camera', title: 'üì∑ Camera' },
              { type: 'component', componentType: 'settings', title: '‚öôÔ∏è Settings' }
            ]
          },
          {
            type: 'column',
            width: 50,
            content: [
              { type: 'component', componentType: 'cursor', title: 'üéØ Cursor Area' }
            ]
          },
          {
            type: 'column',
            width: 25,
            content: [
              { type: 'component', componentType: 'architecture', title: 'üèóÔ∏è Architecture' },
              { type: 'component', componentType: 'metrics', title: 'üìä Metrics' }
            ]
          }
        ]
      }
    };
    
    // =========================================================================
    // PANEL COMPONENTS
    // =========================================================================
    
    function createCameraPanel(container) {
      container.element.innerHTML = `
        <div class="panel">
          <h3>MediaPipe Input</h3>
          <div class="camera-container">
            <video id="camera" autoplay playsinline muted></video>
            <canvas id="canvas"></canvas>
            <div class="gesture-badge" id="gesture-badge">Waiting...</div>
          </div>
        </div>
      `;
    }
    
    function createCursorPanel(container) {
      container.element.innerHTML = `
        <div class="panel" style="padding: 0;">
          <div class="cursor-area" id="cursor-area">
            <div class="cursor cursor-raw" id="cursor-raw"></div>
            <div class="cursor cursor-smooth" id="cursor-smooth"></div>
            <div class="cursor cursor-predict" id="cursor-predict"></div>
          </div>
        </div>
      `;
    }
    
    function createSettingsPanel(container) {
      container.element.innerHTML = `
        <div class="panel">
          <h3>Smoother Settings</h3>
          <div class="setting">
            <label>Smoother Type</label>
            <select id="smoother-select">
              <option value="1euro">1‚Ç¨ Filter (npm 1eurofilter)</option>
              <option value="rapier-smooth">Rapier Smooth (WASM physics)</option>
              <option value="rapier-predict">Rapier Predictive (latency comp)</option>
            </select>
          </div>
          <div class="setting" id="setting-beta">
            <label>1‚Ç¨ Beta (speed coefficient) <span class="value" id="val-beta">0.007</span></label>
            <input type="range" id="slider-beta" min="0" max="0.1" step="0.001" value="0.007">
          </div>
          <div class="setting" id="setting-stiffness">
            <label>Rapier Stiffness <span class="value" id="val-stiffness">400</span></label>
            <input type="range" id="slider-stiffness" min="100" max="1000" step="50" value="400">
          </div>
          <div class="setting" id="setting-damping">
            <label>Rapier Damping <span class="value" id="val-damping">8</span></label>
            <input type="range" id="slider-damping" min="1" max="20" step="1" value="8">
          </div>
        </div>
      `;
    }
    
    function createArchitecturePanel(container) {
      container.element.innerHTML = `
        <div class="panel">
          <h3>Pipeline Architecture</h3>
          <div class="arch-stage active" id="arch-1">
            <span class="num">1</span>
            <span class="name">Input</span>
            <span class="adapter">MediaPipeAdapter</span>
          </div>
          <div class="arch-arrow">‚Üì SensorFrame</div>
          <div class="arch-stage active" id="arch-2">
            <span class="num">2</span>
            <span class="name">Smoother</span>
            <span class="adapter" id="arch-smoother">OneEuroExemplarAdapter</span>
          </div>
          <div class="arch-arrow">‚Üì SmoothedFrame</div>
          <div class="arch-stage" id="arch-3">
            <span class="num">3</span>
            <span class="name">FSM</span>
            <span class="adapter">XStateFSMAdapter</span>
          </div>
          <div class="arch-arrow">‚Üì FSMAction</div>
          <div class="arch-stage active" id="arch-4">
            <span class="num">4</span>
            <span class="name">Output</span>
            <span class="adapter">W3CPointerEventFactory</span>
          </div>
          <div class="arch-arrow">‚Üì PointerEvent</div>
          <div class="arch-stage active" id="arch-5">
            <span class="num">5</span>
            <span class="name">Target</span>
            <span class="adapter">DOMAdapter</span>
          </div>
          <div style="margin-top: 1rem; font-size: 0.65rem; color: var(--text-dim);">
            ‚úÖ Using npm exemplars via thin adapters<br>
            ‚ùå No inline algorithms (enforced by anti-theater-gate)
          </div>
        </div>
      `;
    }
    
    function createMetricsPanel(container) {
      container.element.innerHTML = `
        <div class="panel">
          <h3>Real-Time Metrics</h3>
          <div class="metric"><span class="label">FPS</span><span class="value" id="m-fps">--</span></div>
          <div class="metric"><span class="label">Latency (ms)</span><span class="value" id="m-latency">--</span></div>
          <div class="metric"><span class="label">Raw Jitter</span><span class="value" id="m-jitter-raw">--</span></div>
          <div class="metric"><span class="label">Smooth Jitter</span><span class="value" id="m-jitter-smooth">--</span></div>
          <div class="metric"><span class="label">Gesture</span><span class="value" id="m-gesture">--</span></div>
          <div class="metric"><span class="label">Confidence</span><span class="value" id="m-confidence">--</span></div>
          <div class="metric"><span class="label">Hand</span><span class="value" id="m-hand">--</span></div>
          <div class="metric"><span class="label">Smoother</span><span class="value" id="m-smoother">--</span></div>
        </div>
      `;
    }
    
    // =========================================================================
    // INITIALIZATION
    // =========================================================================
    
    async function initSmoothers() {
      // 1‚Ç¨ Filter adapter (npm 1eurofilter)
      state.smoothers['1euro'] = new OneEuroExemplarAdapter({
        frequency: 60,
        minCutoff: 1.0,
        beta: 0.007
      });
      
      // Rapier Smooth adapter (npm @dimforge/rapier2d-compat)
      state.smoothers['rapier-smooth'] = new RapierPhysicsAdapter({
        mode: 'smoothed',
        stiffness: 400,
        damping: 8
      });
      await state.smoothers['rapier-smooth'].init();
      
      // Rapier Predictive adapter
      state.smoothers['rapier-predict'] = new RapierPhysicsAdapter({
        mode: 'predictive',
        stiffness: 400,
        damping: 5,
        predictionMs: 50
      });
      await state.smoothers['rapier-predict'].init();
      
      state.currentSmoother = state.smoothers['1euro'];
      
      updateStatus('smooth', 'green', 'Smoother: 1‚Ç¨ (npm)');
    }
    
    async function initMediaPipe() {
      try {
        const vision = await FilesetResolver.forVisionTasks(
          'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.22/wasm'
        );
        state.gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task',
            delegate: 'GPU'
          },
          runningMode: 'VIDEO',
          numHands: 1
        });
        updateStatus('mp', 'green', 'MediaPipe: Ready');
        await startCamera();
      } catch (err) {
        updateStatus('mp', 'red', 'MediaPipe: ' + err.message);
        console.error('MediaPipe init failed:', err);
      }
    }
    
    async function startCamera() {
      const video = document.getElementById('camera');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d');
      
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { width: 640, height: 480 } 
      });
      video.srcObject = stream;
      
      video.onloadedmetadata = () => {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        runLoop(video, canvas, ctx);
      };
    }
    
    function runLoop(video, canvas, ctx) {
      if (!state.gestureRecognizer) {
        requestAnimationFrame(() => runLoop(video, canvas, ctx));
        return;
      }
      
      const now = performance.now();
      const results = state.gestureRecognizer.recognizeForVideo(video, now);
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (results.landmarks?.[0]) {
        const hand = results.landmarks[0];
        new DrawingUtils(ctx).drawLandmarks(hand, { color: '#00ff88', lineWidth: 1 });
        
        const tip = hand[8]; // Index fingertip
        const gesture = results.gestures?.[0]?.[0]?.categoryName || 'None';
        const confidence = results.gestures?.[0]?.[0]?.score || 0;
        const handedness = results.handedness?.[0]?.[0]?.categoryName || 'Right';
        
        // Create SensorFrame (adapter input)
        const sensorFrame = {
          ts: now,
          indexTip: { x: tip.x, y: tip.y, z: tip.z },
          gesture,
          confidence,
          hand: handedness
        };
        
        // Update raw cursor
        state.cursors.raw = { x: tip.x, y: tip.y };
        
        // Process through current smoother adapter
        const smoothed = state.currentSmoother.smooth(sensorFrame);
        state.cursors.smooth = { x: smoothed.position.x, y: smoothed.position.y };
        state.cursors.predict = { x: smoothed.prediction.x, y: smoothed.prediction.y };
        
        // Update UI
        updateCursors();
        updateMetrics(gesture, confidence, handedness, smoothed.smootherType);
        document.getElementById('gesture-badge').textContent = gesture;
      }
      
      state.metrics.frames++;
      requestAnimationFrame(() => runLoop(video, canvas, ctx));
    }
    
    function updateCursors() {
      const area = document.getElementById('cursor-area');
      if (!area) return;
      const rect = area.getBoundingClientRect();
      
      const rawEl = document.getElementById('cursor-raw');
      const smoothEl = document.getElementById('cursor-smooth');
      const predictEl = document.getElementById('cursor-predict');
      
      if (rawEl) {
        rawEl.style.left = (state.cursors.raw.x * rect.width) + 'px';
        rawEl.style.top = (state.cursors.raw.y * rect.height) + 'px';
      }
      if (smoothEl) {
        smoothEl.style.left = (state.cursors.smooth.x * rect.width) + 'px';
        smoothEl.style.top = (state.cursors.smooth.y * rect.height) + 'px';
      }
      if (predictEl) {
        predictEl.style.left = (state.cursors.predict.x * rect.width) + 'px';
        predictEl.style.top = (state.cursors.predict.y * rect.height) + 'px';
      }
    }
    
    function updateMetrics(gesture, confidence, hand, smootherType) {
      document.getElementById('m-gesture').textContent = gesture;
      document.getElementById('m-confidence').textContent = (confidence * 100).toFixed(0) + '%';
      document.getElementById('m-hand').textContent = hand;
      document.getElementById('m-smoother').textContent = smootherType;
      
      // FPS calculation
      const now = performance.now();
      if (!state._lastFpsTime) state._lastFpsTime = now;
      if (now - state._lastFpsTime > 1000) {
        document.getElementById('m-fps').textContent = state.metrics.frames;
        state.metrics.frames = 0;
        state._lastFpsTime = now;
      }
    }
    
    function updateStatus(id, color, text) {
      const dot = document.getElementById('dot-' + id);
      const span = document.getElementById('status-' + id);
      if (dot) {
        dot.className = 'status-dot ' + color;
      }
      if (span) {
        span.textContent = text;
      }
    }
    
    function setupSettingsListeners() {
      const smootherSelect = document.getElementById('smoother-select');
      if (smootherSelect) {
        smootherSelect.addEventListener('change', (e) => {
          state.smootherType = e.target.value;
          state.currentSmoother = state.smoothers[state.smootherType];
          
          // Update architecture panel
          const archSmoother = document.getElementById('arch-smoother');
          if (archSmoother) {
            const names = {
              '1euro': 'OneEuroExemplarAdapter',
              'rapier-smooth': 'RapierPhysicsAdapter (smooth)',
              'rapier-predict': 'RapierPhysicsAdapter (predict)'
            };
            archSmoother.textContent = names[state.smootherType];
          }
          
          updateStatus('smooth', 'green', 'Smoother: ' + state.smootherType);
        });
      }
    }
    
    // =========================================================================
    // MAIN
    // =========================================================================
    
    async function main() {
      // Initialize Golden Layout
      const container = document.getElementById('layout-container');
      const layout = new GoldenLayout(container);
      
      layout.registerComponentFactoryFunction('camera', createCameraPanel);
      layout.registerComponentFactoryFunction('cursor', createCursorPanel);
      layout.registerComponentFactoryFunction('settings', createSettingsPanel);
      layout.registerComponentFactoryFunction('architecture', createArchitecturePanel);
      layout.registerComponentFactoryFunction('metrics', createMetricsPanel);
      
      layout.loadLayout(layoutConfig);
      
      // Initialize adapters
      updateStatus('arch', 'green', 'Architecture: HONEST');
      await initSmoothers();
      await initMediaPipe();
      
      // Setup event listeners after layout renders
      setTimeout(setupSettingsListeners, 100);
    }
    
    main().catch(console.error);
  
</script>
</body>
</html>
